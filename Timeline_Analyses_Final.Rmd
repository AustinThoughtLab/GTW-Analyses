---
title: "Timeline_Analyses_Final"
author: "KWilliams"
date: "2/23/2022"
output: html_document
---

```{r install packages, include=FALSE}
#ipak function: install and load multiple R packages.
#check to see if packages are installed. Install them if they are not, then load them into the R session.
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

lib = c("ordinal","gridExtra","MPDiR","tidyr","quickpsy","gmodels", "gplots","tidyverse", "nloptr", "lme4", "ggplot2", "reshape2", "ggpubr", "dplyr", "rstatix", "car", "stats", "coin", "scales", "psych", "ggthemes", "brms")
ipak(lib) #run all packages stored in lib through the ipak function to call them
```

```{r data, echo=FALSE}
d.all <- read.csv('combinedData_cleaned.csv')
```

```{r timeline reliability check}
# Timeline coding reliability check: one-way mixed consistency, single measure ICC
# English only (no 2nd coding for german data)
d.e <- d.all %>%
  filter(language == "english")

  
TimeLine_Reliability <- d.e %>%
  select(distfrommid_c1, distfrommid_c2)
TimeLine_Reliability$distfrommid_c2<- as.numeric(TimeLine_Reliability$distfrommid_c2)
ICC(TimeLine_Reliability) # excellent reliability 
#ICC values less than 0.5 are indicative of poor reliability, values between 0.5 and 0.75 indicate moderate reliability, values between 0.75 and 0.9 indicate good reliability, and values greater than 0.90 indicate excellent reliability.
```

```{r data wrangling, subsetting, coding}
# subset timeline data
d.all.timeline <- d.all %>%
  subset(task == "timeline") %>%
  select(-response, -response1, -response2, -correctr, -correctR)

# adjust responses that were coded as being located exactly "now"
d.TL <- d.all.timeline %>%
  mutate(distfrommid_2 = case_when(distfrommid == 0 & item %in% c("dinner", "nextbday", "tonight", "tomorrow", "nextyear", "aftertomorrow", "nextweek") ~ 0.01,
                                  distfrommid == 0 & item %in% c("lastbday", "lastweek", "yesterday", "breakfast","thismorning","lastyear", "beforeyesterday") ~ -0.01,
                                  distfrommid > 0 ~ distfrommid,
                                  distfrommid < 0 ~ distfrommid))

d.TL <- d.TL %>%
  mutate(item2 = case_when(linenum == 2 & item == "tomorrow" ~ "tomorrow.2",
                           linenum == 3 & item == "yesterday" ~ "yesterday.3",
                           linenum == 4 & item == "tomorrow" ~ "tomorrow.4",
                           linenum == 4 & item == "yesterday" ~ "yesterday.4",
                           TRUE ~ item))

d.TL2 <- d.TL %>%
  mutate(CorrectRank = case_when(linenum == 1 & item2 == "lastbday" ~ 1,
                                 linenum == 1 & item2 == "breakfast" ~ 2, 
                                 linenum == 1 & item2 == "dinner" ~ 3,
                                 linenum == 1 & item2 == "nextbday" ~ 4,
                                 linenum == 2 & item2 == "lastweek" ~ 1,
                                 linenum == 2 & item2 == "thismorning" ~ 2,
                                 linenum == 2 & item2 == "tonight" ~ 3,
                                 linenum == 2 & item2 == "tomorrow.2" ~ 4,
                                 linenum == 3 & item2 == "lastyear" ~ 1,
                                 linenum == 3 & item2 == "yesterday.3" ~ 2,
                                 linenum == 3 & item2 == "nextweek" ~ 3,
                                 linenum == 3 & item2 == "nextyear" ~ 4,
                                 linenum == 4 & item2 == "beforeyesterday" ~ 1,
                                 linenum == 4 & item2 == "yesterday.4" ~ 2,
                                 linenum == 4 & item2 == "tomorrow.4" ~ 3,
                                 linenum == 4 & item2 == "aftertomorrow" ~ 4,
  ))
```

```{r code item proximity: proximal vs. distal}
#TempDistance indicates how far events should be from NOW -- 1 for more proximal events/times, 2 for more distal events/times
d.TL2$TempDistance <- factor(with(d.TL2, ifelse(item2 %in% c("breakfast","dinner","thismorning","tonight","yesterday.3", "yesterday.4", "tomorrow.2", "tomorrow.4"), 1, 
                                                ifelse(item2 %in% c("lastweek","nextweek","lastbday","nextbday","lastyear","nextyear", "beforeyesterday", "aftertomorrow"), 2,
                                                         "other"))))
```

```{r code past/future placement}
d.TL2$BNStatus <- with(d.TL2,ifelse(item %in% c("breakfast", "lastbday", "lastweek", "thismorning", "yesterday","lastyear", "beforeyesterday"), 1, 0))
d.TL2$BNResponse <- with(d.TL2, ifelse(distfrommid_2 < 0, 1, 0))

d.TL2$BNCorrect <- with(d.TL2, ifelse(BNStatus == BNResponse, 1, 0))
d.TL2$PastItem <- factor(d.TL2$BNStatus)

#check that adults are getting DS right
d.test <- d.TL2 %>%
  filter(agegroup == "adult") %>%
  group_by(item, language) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T))*100, # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T))*100, # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
  

# sum code variables for glmer
# sum code language and itemtype
d.TL2$language <- as.factor(d.TL2$language)
d.TL2 <- mutate(d.TL2, language.sc = language)
contrasts(d.TL2$language.sc) <- contr.sum(2)
d.TL2$itemtype <- as.factor(d.TL2$itemtype)
d.TL2 <- mutate(d.TL2, itemtype.sc = itemtype)
contrasts(d.TL2$itemtype.sc) <- contr.sum(2)

t.lm1 <- glmer(BNCorrect ~ language.sc *itemtype.sc*scale(ageyears) + (1|subjid), family = 'binomial', data=d.TL2, control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))) # main effects of age, and itemtype, age x language interaction and itemtype x language interaction (and three-way interaction)
summary(t.lm1) 
Anova(t.lm1, contrasts=list(topic=contr.sum, sys=contr.sum), Type=3) #  item type and age both improve the fit of the model


#Wilcox_test for item level comparisons
DeicticStatus_Timeline <- d.TL2 %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = BNCorrect ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
DeicticStatus_Timeline


#t.lm2 <- glmer(BNCorrect ~ itemtype.sc*scale(ageyears) + (1|subjid), family = 'binomial', data=d.TL2EN, control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))) # language and age are significant predictors of BNCorrect
#summary(t.lm2) 
#Anova(t.lm2, contrasts=list(topic=contr.sum, sys=contr.sum), Type=3) # age, item type, and language all improve the fit of the model


# across both languages, within each agegroup what was performance like?
Table_2 <- d.TL2 %>%
  group_by(agegroup, language) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T))*100, # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T))*100, # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
Table_2


# calculate the average accuracy for all items' placement relative to "now" for each timeline
deicticstatus.sum2 <- d.TL2 %>%
  group_by(subjid, linenum, language) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T))*100, # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T))*100, # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
deicticstatus.sum2

# now create a mean deictic status accuracy for each participant and each type of timeline
deicticstatus.sum3 <- d.TL2 %>%
  group_by(subjid, itemtype, language, agegroup) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T))*100, # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T))*100, # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
deicticstatus.sum3

```

```{r t tests for past/future status placements}

with(subset(d.TL2, agegroup=="3"), t.test(x=BNCorrect, mu=.5)) # not better than chance
with(subset(d.TL2, agegroup=="3" & language == "english"), t.test(x=BNCorrect, mu=.5)) # greater than chance
with(subset(d.TL2, agegroup=="3" & language == "german"), t.test(x=BNCorrect, mu=.5)) # greater than chance

with(subset(d.TL2, agegroup=="4"), t.test(x=BNCorrect, mu=.5)) # greater than chance

with(subset(d.TL2, agegroup=="4" & language == "english"), t.test(x=BNCorrect, mu=.5)) # greater than chance
with(subset(d.TL2, agegroup=="4" & language == "german"), t.test(x=BNCorrect, mu=.5)) # greater than chance

#with(subset(d.TL4, agegroup %in% c("6", "7")), t.test(BNCorrect ~ agegroup, var.equal=T)) # no difference
#with(subset(d.TL4, agegroup %in% c("6", "adult")), t.test(BNCorrect ~ agegroup, var.equal=T)) # 6-year-olds not adult-like
with(subset(d.TL2, agegroup %in% c("7", "adult")), t.test(BNCorrect ~ agegroup, var.equal=T)) # 7-year-olds not adult-like 

with(subset(d.TL2, agegroup %in% c("7", "adult") & language == "german"), t.test(BNCorrect ~ agegroup, var.equal=T)) # 7-year-olds not adult-like 
with(subset(d.TL2, agegroup %in% c("7", "adult") & language == "english"), t.test(BNCorrect ~ agegroup, var.equal=T)) # 7-year-olds not adult-like 


with(subset(d.TL2, agegroup == "3"), t.test(BNCorrect ~ language, var.equal = T)) # significant difference at age 3 between English- and German-speakers 
with(subset(d.TL2, agegroup == "4"), t.test(BNCorrect ~ language, var.equal = T)) # no difference at age 4 between English- and German-speakers 
with(subset(d.TL2, agegroup == "5"), t.test(BNCorrect ~ language, var.equal = T)) # no difference at age 5 between English- and German-speakers 
with(subset(d.TL2, agegroup == "6"), t.test(BNCorrect ~ language, var.equal = T)) # no difference at age 6 between English- and German-speakers 
with(subset(d.TL2, agegroup == "7"), t.test(BNCorrect ~ language, var.equal = T)) # no difference at age 7 between English- and German-speakers 

# are 3-year-olds or adults driving the main effects (language + age) and their interaction? looks like no!

d.TL3 <- d.TL2 %>%
  filter(agegroup != "adult") %>% # remove adults
  mutate(ageyears = as.numeric(ageyears))
Temp.PF.m1 <- lm(BNCorrect ~ ageyears, d.TL3)
summary(Temp.PF.m1) # age is a significant predictor of past/future placement on the timeline

d.TL4 <- d.TL3 %>%
  filter(agegroup %in% c("4", "5", "6", "7"))

Temp.PF.m2 <- lm(BNCorrect ~ language * ageyears, d.TL4)
summary(Temp.PF.m2) # age is still a significant predictor of past/future placement on the timeline after 3-year-olds are excluded 
```

```{r plot proportion correct for past/future status placement (each language separately)}
# first recode correct variable
d.TL2$BNCorrect_cat[d.TL2$BNCorrect == 0] <- 'Incorrect'
d.TL2$BNCorrect_cat[d.TL2$BNCorrect == 1] <- 'Correct'

# calculate proportions (English Data)
BN.eprop <- d.TL2 %>%
  filter(language == "english") %>%
  count(agegroup, BNCorrect_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
as.data.frame(BN.eprop) # strip tbl_df() properties to print

# create ggplot
prop_e <- ggplot(data = BN.eprop, 
                 aes (x = agegroup, y = prop, fill = BNCorrect_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) + # or =waiver() or NULL for the default labels computed by the transformation object
  scale_fill_few('Medium', drop = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Past/Future Assignment',
       title = 'Proportions Correct by Age Group (English Data)')
prop_e

# calculate proportions (English Data)
BN.gprop <- d.TL2 %>%
  filter(language == "german") %>%
  count(agegroup, BNCorrect_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
as.data.frame(BN.gprop, na.omit = T) # strip tbl_df() properties to print

# create ggplot
prop_g <- ggplot(data = BN.gprop, 
                 aes (x = agegroup, y = prop, fill = BNCorrect_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) + # or =waiver() or NULL for the default labels computed by the transformation object
  scale_fill_few('Medium', drop = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Past/Future Assignment',
       title = 'Proportions Correct by Age Group (German Data)')
prop_g

## now create a mean deictic status accuracy for each type of timeline for each language and age group
deicticstatus.sum3.english <- d.TL2 %>%
  filter(language == "english") %>%
  group_by(itemtype, agegroup) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T)), # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T)), # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
deicticstatus.sum3.english

#Plot correct status by item type (for each language separately)
# first english-speakers
EnglishStatus.timeline <- ggplot(data=deicticstatus.sum3.english, aes(x=agegroup, y=DS.m, ymin = DS.lower, ymax = DS.upper, group=itemtype, color=itemtype)) +
  geom_line(aes(color=itemtype))+
  geom_errorbar(width = 0.2) +
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
  theme(legend.position = "top") +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))
EnglishStatus.timeline

# now german-speakers

deicticstatus.sum3.german <- d.TL2 %>%
  filter(language == "german") %>%
  group_by(itemtype, agegroup) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T)), # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T)), # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
deicticstatus.sum3.german

GermanStatus.timeline <- ggplot(data=deicticstatus.sum3.german, aes(x=agegroup, y=DS.m, group=itemtype, color=itemtype, ymin = DS.lower, ymax = DS.upper)) +
  geom_line(aes(color=itemtype))+
  geom_errorbar(width = 0.2) +
  geom_point() +
  ylab('Proportion Correct') +
  xlab('German Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
  theme(legend.position = "top") +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))
GermanStatus.timeline

ggsave("DS_graphs.jpeg", arrangeGrob(EnglishStatus.timeline, GermanStatus.timeline), height = 10, width = 7, dpi = 300)

```

```{r plot proportion correct for past/future status placement (collpased across languages)}
# first recode correct variable
d.TL2$BNCorrect_cat[d.TL2$BNCorrect == 0] <- 'Incorrect'
d.TL2$BNCorrect_cat[d.TL2$BNCorrect == 1] <- 'Correct'

d.TL2$agegroup <- as.factor(d.TL2$agegroup)

# calculate proportions (English Data)
BNprop <- d.TL2 %>%
  count(agegroup, BNCorrect_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
as.data.frame(BNprop) # strip tbl_df() properties to print

# create ggplot
prop_DS <- ggplot(data = BNprop, 
                 aes (x = agegroup, y = prop, fill = BNCorrect_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) + # or =waiver() or NULL for the default labels computed by the transformation object
  scale_fill_few('Medium', drop = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Past/Future Assignment',
       title = 'Proportions Correct by Age Group (English Data)')
prop_DS


## now create a mean deictic status accuracy for each type of timeline for each  age group
DS.sum <- d.TL2 %>%
  group_by(itemtype, agegroup) %>%
  summarize(n = n(),
            DS.m = (mean(BNCorrect, na.rm = T)), # who got correct status (first answer)
            DS.sd = (sd(BNCorrect, na.rm = T)), # standard deviation
            DS.se = DS.sd/sqrt(n), # calculate standard error
            DS.lower = DS.m - DS.se, # calculate lower 95% CI
            DS.upper = DS.m + DS.se) # calculate upper 95% CI
DS.sum

#Plot correct status by item type (for each language separately)
# first english-speakers
DS.timeline <- ggplot(data=DS.sum, aes(x=agegroup, y=DS.m, group=itemtype, color=itemtype)) +
  geom_line(aes(color=itemtype))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
  theme(legend.position = "top") +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))
DS.timeline

ggsave("DS.timeline.png", DS.timeline, dpi = 300)

```

```{r plot development of past/future status knowledge on timeline task}

plot.data <- subset(d.TL2)
plot.data.agg <- aggregate(BNCorrect ~ agegroup, plot.data, mean)
plot.data.agg$varRank <- aggregate(BNCorrect ~ agegroup, plot.data, sd)$BNCorrect

plot.pastfuture <- ggplot(data=plot.data.agg, aes(x=agegroup, y=BNCorrect)) + 
  # geom_hline(yintercept=1, linetype="solid",color="black",size=1.3) +
  geom_hline(yintercept=.5, linetype="dashed",color="red",size=1.3) +
  geom_pointrange(size=1.5, position=position_dodge(width=0.3), aes(ymax=BNCorrect + varRank, ymin=BNCorrect - varRank)) +
  scale_x_discrete(name = "Age (years)") +
  scale_y_continuous(name = "Mean Deictic Status Knowledge", breaks= c(.2, .3, .4, .5,.6,.7,.8,.9,1), limits = c(.2, 1)) +
  theme(axis.title = element_text(size=12))
plot.pastfuture

plot.dataGerman <- d.TL2 %>%
  filter(language == "german")
plot.data.aggGerman <- aggregate(BNCorrect ~ agegroup, plot.dataGerman, mean)
plot.data.aggGerman$varRank <- aggregate(BNCorrect ~ agegroup, plot.dataGerman, sd)$BNCorrect

plot.pastfutureGerman <- ggplot(data=plot.data.aggGerman, aes(x=agegroup, y=BNCorrect)) + 
  # geom_hline(yintercept=1, linetype="solid",color="black",size=1.3) +
  geom_hline(yintercept=.5, linetype="dashed",color="red",size=1.3) +
  geom_pointrange(size=1.5, position=position_dodge(width=0.3), aes(ymax=BNCorrect + varRank, ymin=BNCorrect - varRank)) +
  scale_x_discrete(name = "German Speakers' Age (years)") +
  scale_y_continuous(name = "Mean Deictic Status Knowledge", breaks= c(.2, .3, .4, .5,.6,.7,.8,.9,1), limits = c(.2, 1)) +
  theme(axis.title = element_text(size=12))
plot.pastfutureGerman

ggsave("DS_GermanDev_Timeline.png", plot.pastfutureGerman, dpi = 300, height = 3, width = 3)

plot.dataEnglish <- d.TL2 %>%
  filter(language == "english")
plot.data.aggEnglish <- aggregate(BNCorrect ~ agegroup, plot.dataEnglish, mean)
plot.data.aggEnglish$varRank <- aggregate(BNCorrect ~ agegroup, plot.dataEnglish, sd)$BNCorrect

plot.pastfutureEnglish <- ggplot(data=plot.data.aggEnglish, aes(x=agegroup, y=BNCorrect)) + 
  # geom_hline(yintercept=1, linetype="solid",color="black",size=1.3) +
  geom_hline(yintercept=.5, linetype="dashed",color="red",size=1.3) +
  geom_pointrange(size=1.5, position=position_dodge(width=0.3), aes(ymax=BNCorrect + varRank, ymin=BNCorrect - varRank)) +
  scale_x_discrete(name = "English Speakers' Age (years)") +
  scale_y_continuous(name = "Mean Deictic Status Knowledge", breaks= c(.2, .3, .4, .5,.6,.7,.8,.9,1), limits = c(.2, 1)) +
  theme(axis.title = element_text(size=12))
plot.pastfutureEnglish

ggsave("DS_EnglishDev_Timeline.png", plot.pastfutureEnglish, dpi = 300, height = 3, width = 3)

```

```{r rank order error calculation (across 16 items)}
# if necessary, unload plyr for this next part
#detach("package:plyr", unload = TRUE)
d.TL2 <- d.TL2 %>%
  group_by(subjid, linenum) %>%
  mutate(Rank = dense_rank(distfrommid_2))

d.TL2$RankDif <- abs(d.TL2$CorrectRank - d.TL2$Rank)
d.TL2$IsCorrect_Rank <- with(d.TL2, ifelse(RankDif=="0", 1, 0))
d.TL2$item <- factor(d.TL2$item2)

#Now figure out the trialnumber and make it numeric
d.TL2$TrialNum <- with(d.TL2,ifelse(order==1,
                                      match(item2,c("breakfast","nextbday","dinner","lastbday","lastweek","tomorrow.2",
                                                   "tonight","thismorning","nextweek","nextyear","yesterday.3","lastyear", 
                                                   "yesterday.4","tomorrow.4", "aftertomorrow", "beforeyesterday")
                                      ),
                                      match(item2,c("lastbday","dinner","nextbday","breakfast","thismorning","tonight",
                                                   "tomorrow.2","lastweek","lastyear","yesterday.3","nextyear","nextweek", 
                                                   "tomorrow.4", "yesterday.4", "beforeyesterday", "aftertomorrow")
                                      )
))
d.TL2$TrialNum <- as.numeric(d.TL2$TrialNum)

#Sum for the entire line, to get an aggregate score of how much people diverged (MAX = 8)
# from the correct ordering. (i.e. error score for each line)
d.TL2$AgeYears <- as.factor(d.TL2$agegroup)
d.TL3 <- d.TL2 %>%
  group_by(subjid, linenum) %>%
  mutate(sumRankDif = sum(RankDif, na.rm = T))

#Now average that error score across all the participant' timelines 
d.TL4 <- d.TL3 %>%
  group_by(subjid) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

# now average error score across all participants by language 
d.TL5 <- d.TL3 %>%
  group_by(language) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

# now average for each item type: diectic vs. event
d.TL6 <- d.TL3 %>%
  group_by(itemtype) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

# now average error score across all participants by language and age
d.TL7 <- d.TL3 %>%
  group_by(language, AgeYears) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

# Finally calculate mean accuracy of order knowledge, for each participant, language group, and Timeline Type. 
d.TL8 <- d.TL3 %>%
  group_by(language, subjid, itemtype) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

#Anova of rank dif
#RankError.aov <- aov(RankDif ~ ageyears + itemtype + language, data = d.TL8)
#RankError.aov <- aov(RankDif ~ AgeYears * itemtype + language + Error(subjid/(itemtype)),d.TL5)
#RankError.aov <- aov(RankDif ~ AgeYears * itemtype + language + subjid,d.TL5)
#summary(RankError.aov) #highly sig effect of age and language

#Anova of aggregate rank order
RankError.aov <- aov(avgRankDif ~ ageyears + itemtype + language, data = d.TL8)
#RankError.aov <- aov(RankDif ~ AgeYears * itemtype + language + Error(subjid/(itemtype)),d.TL5)
#RankError.aov <- aov(RankDif ~ AgeYears * itemtype + language + subjid,d.TL5)
summary(RankError.aov) #highly sig effect of age and language; doesn't matter if we use RankDif or AvgRankDif


#linear regression of order error onto language 
d.TL9 <- d.TL3 %>%
  group_by(language, subjid) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))
  
rank.agg.lm <- lm(RankDif ~ language, d.TL9)
summary(rank.agg.lm) # language is not significant

#linear regression of order error onto age (in years) English only 
d.TL10 <- d.TL3 %>%
  filter(language == "english") %>%
  group_by(AgeYears, subjid) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

d.TL10$AgeYears <- as.numeric(as.character(d.TL10$AgeYears))
Engrank.agg.lm <- lm(RankDif ~ AgeYears, d.TL10)
summary(Engrank.agg.lm) # age is highly significant

#linear regression of order error onto age (in years) German only 
d.TL11 <- d.TL3 %>%
  filter(language == "german") %>%
  group_by(AgeYears, subjid) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

d.TL11$AgeYears <- as.numeric(as.character(d.TL11$AgeYears))
Germrank.agg.lm <- lm(RankDif ~ AgeYears, d.TL11)
summary(Germrank.agg.lm) # age is highly significant

# across both languages, within each agegroup what was performance like?
rankorder.sum <- d.TL2 %>%
  group_by(agegroup, language, linenum) %>%
  summarize(n = n(),
            RO.m = (mean(RankDif, na.rm = T)), # who got correct status (first answer)
            RO.sd = (sd(RankDif, na.rm = T)), # standard deviation
            RO.se = RO.sd/sqrt(n), # calculate standard error
            RO.lower = RO.m - RO.se, # calculate lower 95% CI
            RO.upper = RO.m + RO.se) # calculate upper 95% CI
rankorder.sum
```

```{r rank order N-back method}
d.TL2$ComparedToPrevious <- ""
d.TL2$CorrComparedToPrevious <- ""
RelRankData <- subset(d.TL2, subjid=="nothing")
#library ("berryFunctions")
#RelRankData2 <- insertRows(RelRankData, 1:5573, new = NA)
for(sub_i in (unique(d.TL2$subjid))){
  for(trial_i in c(2,3,4,6,7,8,10,11,12,14,15,16)){
    foo <- subset(d.TL2, subjid==sub_i & TrialNum==trial_i)
    fooPrev <- subset(d.TL2, subjid==sub_i & TrialNum==trial_i-1)
    foo$ComparedToPrevious <- ifelse(foo$Rank > fooPrev$Rank, "R","L") # code where they placed trial in relation to previous trial (was it to the right or to the left?)
    foo$CorrComparedToPrevious <- ifelse(foo$CorrectRank > fooPrev$CorrectRank, "R","L") # code where the correct placement is in relation to the previous trial (is it to the right or to the left?)
    RelRankData <- rbind(RelRankData, foo) # cmobine all of this information into new dataframe
  }
  cat(sub_i, "\r") # these next three lines print the trial the loop that currently running
  flush.console()
  Sys.sleep(1)
  }

RelRankData$AccRelRank <- with(RelRankData, ifelse(ComparedToPrevious == CorrComparedToPrevious, 1, 0))

SumAccRelRank <- RelRankData %>%
  group_by(itemtype, agegroup) %>%
  mutate(avgRelRankDif = mean(AccRelRank, na.rm = T))

# sum code variables for glmer
# sum code language and itemtype
RelRankData$language <- as.factor(RelRankData$language)
RelRankData <- mutate(RelRankData, language.sc = language)
contrasts(RelRankData$language.sc) <- contr.sum(2)
RelRankData$itemtype <- as.factor(RelRankData$itemtype)
RelRankData <- mutate(RelRankData, itemtype.sc = itemtype)
contrasts(RelRankData$itemtype.sc) <- contr.sum(2)

# does language spoken, timeline type (event vs. deictic), or age predict children's correct order placement on this 1-back measure?
t.lm2 <- glmer(AccRelRank ~ language.sc *itemtype.sc*scale(ageyears) + (1|subjid), family = 'binomial', data=RelRankData, control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))) # main effects of age, and itemtype, age x language interaction and itemtype x language interaction (and three-way interaction)
summary(t.lm2) 
Anova(t.lm2, contrasts=list(topic=contr.sum, sys=contr.sum), Type=3) #  item type and age both improve the fit of the model

Table_3 <- RelRankData %>%
  group_by(language, agegroup) %>%
  summarize(n = n(),
          BackOrder.m = (mean(AccRelRank, na.rm = T)), # who got correct status (first answer)
          BackOrder.sd = (sd(AccRelRank, na.rm = T)), # standard deviation
          BackOrder.se = BackOrder.sd/sqrt(n), # calculate standard error
          BackOrder.lower = (BackOrder.m - BackOrder.se)) # calculate lower 95% CI
Table_3

RelRankData_summary2 <- RelRankData %>%
  group_by(itemtype, language, agegroup) %>%
  summarize(n = n(),
          BackOrder.m = (mean(AccRelRank, na.rm = T)), # who got correct status (first answer)
          BackOrder.sd = (sd(AccRelRank, na.rm = T)), # standard deviation
          BackOrder.se = BackOrder.sd/sqrt(n), # calculate standard error
          BackOrder.lower = BackOrder.m - BackOrder.se, # calculate lower 95% CI
          BackOrder.upper = BackOrder.m + BackOrder.se) # calculate upper 95% CI
RelRankData_summary2



#### t-test for order knowledge on this 1-back measure
with(subset(RelRankData, agegroup=="3"), t.test(x=AccRelRank, mu=.5)) # not better than chance
with(subset(RelRankData, agegroup=="3" & language == "english"), t.test(x=AccRelRank, mu=.5)) # greater than chance
with(subset(RelRankData, agegroup=="3" & language == "german"), t.test(x=AccRelRank, mu=.5)) # greater than chance

with(subset(RelRankData, agegroup=="4"), t.test(x=AccRelRank, mu=.5)) # greater than chance

with(subset(RelRankData, agegroup=="4" & language == "english"), t.test(x=AccRelRank, mu=.5)) # greater than chance
with(subset(RelRankData, agegroup=="4" & language == "german"), t.test(x=AccRelRank, mu=.5)) # greater than chance

with(subset(RelRankData, agegroup %in% c("7", "adult")), t.test(AccRelRank ~ agegroup, var.equal=T)) # 7-year-olds not adult-like 

with(subset(RelRankData, agegroup %in% c("7", "adult") & language == "german"), t.test(AccRelRank ~ agegroup, var.equal=T)) # 7-year-olds not adult-like 
with(subset(RelRankData, agegroup %in% c("7", "adult") & language == "english"), t.test(AccRelRank ~ agegroup, var.equal=T)) # 7-year-olds not adult-like 


with(subset(RelRankData, agegroup == "3"), t.test(AccRelRank ~ language, var.equal = T)) # significant difference at age 3 between English- and German-speakers 
with(subset(RelRankData, agegroup == "4"), t.test(AccRelRank ~ language, var.equal = T)) # no difference at age 4 between English- and German-speakers 
with(subset(RelRankData, agegroup == "5"), t.test(AccRelRank ~ language, var.equal = T)) # no difference at age 5 between English- and German-speakers 
with(subset(RelRankData, agegroup == "6"), t.test(AccRelRank ~ language, var.equal = T)) # no difference at age 6 between English- and German-speakers 
with(subset(RelRankData, agegroup == "7"), t.test(AccRelRank ~ language, var.equal = T)) # no difference at age 7 between English- and German-speakers 

```

```{r graph proportion correct for order knowledge on N-back method for each language separately}
# first english-speakers
BackOrder.englishsum <- RelRankData %>%
  filter(language == "english") %>%
  group_by(itemtype, agegroup) %>%
  summarize(n = n(),
            BackOrder.m = (mean(AccRelRank, na.rm = T)), # who got correct status (first answer)
            BackOrder.sd = (sd(AccRelRank, na.rm = T)), # standard deviation
            BackOrder.se = BackOrder.sd/sqrt(n), # calculate standard error
            BackOrder.lower = BackOrder.m - BackOrder.se, # calculate lower 95% CI
            BackOrder.upper = BackOrder.m + BackOrder.se) # calculate upper 95% CI
BackOrder.englishsum 

EnglishBackOrder.timeline <- ggplot(data=BackOrder.englishsum, aes(x=agegroup, y=BackOrder.m, ymin = BackOrder.lower, ymax = BackOrder.upper, group=itemtype, color=itemtype)) +
  geom_line(aes(color=itemtype))+
  geom_errorbar(width = 0.2) +
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
  theme(legend.position = "top") +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))
EnglishBackOrder.timeline

# now german-speakers

BackOrder.germansum <- RelRankData %>%
  filter(language == "german") %>%
  group_by(itemtype, agegroup) %>%
  summarize(n = n(),
            BackOrder.m = (mean(AccRelRank, na.rm = T)), # who got correct status (first answer)
            BackOrder.sd = (sd(AccRelRank, na.rm = T)), # standard deviation
            BackOrder.se = BackOrder.sd/sqrt(n), # calculate standard error
            BackOrder.lower = BackOrder.m - BackOrder.se, # calculate lower 95% CI
            BackOrder.upper = BackOrder.m + BackOrder.se) # calculate upper 95% CI
BackOrder.germansum 

GermanBackOrder.timeline <- ggplot(data=BackOrder.germansum , aes(x=agegroup, y=BackOrder.m, group=itemtype, color=itemtype, ymin = BackOrder.lower, ymax = BackOrder.upper)) +
  geom_line(aes(color=itemtype))+
  geom_errorbar(width = 0.2) +
  geom_point() +
  ylab('Proportion Correct') +
  xlab('German Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
  theme(legend.position = "top") +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"))
GermanBackOrder.timeline

ggsave("BackOrder_graphs.jpeg", arrangeGrob(EnglishBackOrder.timeline, GermanBackOrder.timeline), height = 10, width = 7, dpi = 300)

```


###### KATIE LEFT OFF HERE ON 4/5/22

```{r analysis of ordinal rank -- t-test on mean accuracy-- }
# t-tests by age of aggregate Rank error (mean accuracy) ####
Temp.TL12 <- d.TL3 %>%
  group_by(subjid, language, ageyears) %>%
  mutate(avgRankDif = mean(RankDif, na.rm = T))

t.test(avgRankDif ~ language, var.equal = T, data = Temp.TL12) # difference in RankDif between language groups
library(effsize)
cohen.d(avgRankDif ~ language, data = Temp.TL12)

Temp.Eng <- Temp.TL12 %>%
  filter(language == 'english')
Temp.Ger <- Temp.TL12 %>%
  filter(language == 'german')

#with(subset(Temp.TL14, AgeYears %in% c("3")), t.test(RankDif, mu=5))
#with(subset(Temp.TL14, AgeYears %in% c("4")), t.test(RankDif, mu = 5))
#with(subset(Temp.TL14, AgeYears %in% c("5")), t.test(RankDif, mu = 5))
#with(subset(Temp.TL14, AgeYears %in% c("6")), t.test(RankDif, mu = 5))
#with(subset(Temp.TL14, AgeYears %in% c("7")), t.test(RankDif, mu = 5))

with(subset(Temp.Eng, AgeYears %in% c("3")), t.test(RankDif, mu=5))
with(subset(Temp.Ger, AgeYears %in% c("3")), t.test(RankDif, mu=5))

with(subset(Temp.Eng, AgeYears %in% c("4")), t.test(RankDif, mu=5))
with(subset(Temp.Ger, AgeYears %in% c("4")), t.test(RankDif, mu=5))

with(subset(Temp.TL14Eng, AgeYears %in% c("5")), t.test(RankDif, mu=5))
with(subset(Temp.TL14Ger, AgeYears %in% c("5")), t.test(RankDif, mu=5))

with(subset(Temp.TL14Eng, AgeYears %in% c("6")), t.test(RankDif, mu=5))
with(subset(Temp.TL14Ger, AgeYears %in% c("6")), t.test(RankDif, mu=5))

with(subset(Temp.TL14Eng, AgeYears %in% c("7")), t.test(RankDif, mu=5))
with(subset(Temp.TL14Ger, AgeYears %in% c("7")), t.test(RankDif, mu=5))

#with(subset(Temp.TL14, AgeYears %in% c("3","4")), t.test(RankDif~AgeYears, var.equal=T))
with(subset(Temp.TL14, AgeYears %in% c("4","5")), t.test(RankDif~AgeYears, var.equal=T))
with(subset(Temp.TL14, AgeYears %in% c("5","6")), t.test(RankDif~AgeYears, var.equal=T))
with(subset(Temp.TL14, AgeYears %in% c("6","7")), t.test(RankDif~AgeYears, var.equal=T))

with(subset(Temp.Eng, AgeYears %in% c("6","adult")), t.test(RankDif~AgeYears, var.equal=T))
with(subset(Temp.Ger, AgeYears %in% c("6","adult")), t.test(RankDif~AgeYears, var.equal=T))
with(subset(Temp.Eng, AgeYears %in% c("7","adult")), t.test(RankDif~AgeYears, var.equal=T))
with(subset(Temp.Ger, AgeYears %in% c("7","adult")), t.test(RankDif~AgeYears, var.equal=T))
```

```{r plot development of avg rank order knowledge on timeline task}

plot.data <- subset(Temp.TL12)
plot.data.agg <- aggregate(IsCorrect_Rank ~ agegroup, plot.data, mean)
plot.data.agg$varRank <- aggregate(IsCorrect_Rank ~ agegroup, plot.data, sd)$IsCorrect_Rank

plot.RankDif <- ggplot(data=plot.data.agg, aes(x=agegroup, y=IsCorrect_Rank)) + 
  # geom_hline(yintercept=1, linetype="solid",color="black",size=1.3) +
  geom_hline(yintercept=.5, linetype="dashed",color="red",size=1.3) +
  geom_pointrange(size=1.5, position=position_dodge(width=0.3), aes(ymax=IsCorrect_Rank + varRank, ymin=IsCorrect_Rank - varRank)) +
  scale_x_discrete(name = "Age (years)") +
  scale_y_continuous(name = "Mean Rank Order Knowledge ", breaks= c(.2, .3, .4, .5,.6,.7,.8,.9,1), limits = c(.2, 1)) +
  theme(axis.title = element_text(size=20))
plot.RankDif 

plot.dataGerman <- Temp.TL12 %>%
  filter(language == "german")
plot.data.aggGerman <- aggregate(IsCorrect_Rank ~ agegroup, plot.dataGerman, mean)
plot.data.aggGerman$varRank <- aggregate(IsCorrect_Rank ~ agegroup, plot.dataGerman, sd)$IsCorrect_Rank

plot.RankDifGerman <- ggplot(data=plot.data.aggGerman, aes(x=agegroup, y=IsCorrect_Rank)) + 
  # geom_hline(yintercept=1, linetype="solid",color="black",size=1.3) +
  geom_hline(yintercept=.5, linetype="dashed",color="red",size=1.3) +
  geom_pointrange(size=1.5, position=position_dodge(width=0.3), aes(ymax=IsCorrect_Rank + varRank, ymin=IsCorrect_Rank - varRank)) +
  scale_x_discrete(name = "German Speakers' Age (years)") +
  scale_y_continuous(name = "Mean Rank Order Knowledge ", breaks= c(.2, .3, .4, .5,.6,.7,.8,.9,1), limits = c(.2, 1)) +
  theme(axis.title = element_text(size=12))
plot.RankDifGerman
ggsave("RankOrder_GermanDev_Timeline.png", plot.RankDifGerman, dpi = 300, height = 3, width = 3)

plot.dataEnglish<- Temp.TL12 %>%
  filter(language == "english")
plot.data.aggEnglish <- aggregate(IsCorrect_Rank ~ agegroup, plot.dataEnglish, mean)
plot.data.aggEnglish$varRank <- aggregate(IsCorrect_Rank ~ agegroup, plot.dataEnglish, sd)$IsCorrect_Rank

plot.RankDifEnglish <- ggplot(data=plot.data.aggGerman, aes(x=agegroup, y=IsCorrect_Rank)) + 
  # geom_hline(yintercept=1, linetype="solid",color="black",size=1.3) +
  geom_hline(yintercept=.5, linetype="dashed",color="red",size=1.3) +
  geom_pointrange(size=1.5, position=position_dodge(width=0.3), aes(ymax=IsCorrect_Rank + varRank, ymin=IsCorrect_Rank - varRank)) +
  scale_x_discrete(name = "English Speakers' Age (years)") +
  scale_y_continuous(name = "Mean Rank Order Knowledge ", breaks= c(.2, .3, .4, .5,.6,.7,.8,.9,1), limits = c(.2, 1)) +
  theme(axis.title = element_text(size=12))
plot.RankDifEnglish
ggsave("RankOrder_EnglishDev_Timeline.png", plot.RankDifEnglish, dpi = 300, height = 3, width = 3)
```

```{r check for item order effects on past/future placement}
# check for item order effects

Time.TL4 <- aggregate(BNCorrect ~ ageyears + subjid + order + itemtype, d.TL2, mean)
Time.TL5 <- aggregate(BNCorrect ~ ageyears + subjid + order + item, d.TL2, mean)

Temp.PF.ord.aov <- aov(BNCorrect ~ ageyears * itemtype * order, d.TL2)
summary(Temp.PF.ord.aov)  # effect of itemtype 

Temp.PF.ord.d <- aov(BNCorrect ~ ageyears *  order, subset(d.TL2, itemtype=="deictic"))
summary(Temp.PF.ord.d)   # main effect of age, no effect of order or interaction

Temp.PF.ord.e <- aov(BNCorrect ~ ageyears *  order, subset(d.TL2, itemtype=="event"))
summary(Temp.PF.ord.e) # main effect of age, no effect of order or interaction

with(subset(Temp.PF6, Item=='BreakfastToday' & AgeYears !='adult'), t.test(BNRight ~ Order, var.equal=T))  # first in order 1
with(subset(Temp.PF6, Item=='LastAge' & AgeYears !='adult'), t.test(BNRight ~ Order, var.equal=T))  # first in order 2
with(subset(Temp.PF6, Item=='LastWeek' & AgeYears !='adult'), t.test(BNRight ~ Order, var.equal=T))  # first in order 1
with(subset(Temp.PF6, Item=='ThisMorning' & AgeYears !='adult'), t.test(BNRight ~ Order, var.equal=T)) # first in order 2
with(subset(Temp.PF6, Item=='NextWeek' & AgeYears !='adult'), t.test(BNRight ~ Order, var.equal=T)) # first in order 1 -- better when tested last vs first
with(subset(Temp.PF6, Item=='LastYear' & AgeYears !='adult'), t.test(BNRight ~ Order, var.equal=T)) # first in order 2

with(subset(Temp.TL, Item=='BreakfastToday' & AgeYears !='adult'), t.test(RankRight ~ Order, var.equal=T))  # first in order 1
with(subset(Temp.TL, Item=='LastAge' & AgeYears !='adult'), t.test(RankRight ~ Order, var.equal=T))  # first in order 2; marginally better in order 2
with(subset(Temp.TL, Item=='LastWeek' & AgeYears !='adult'), t.test(RankRight ~ Order, var.equal=T))  # first in order 1
with(subset(Temp.TL, Item=='ThisMorning' & AgeYears !='adult'), t.test(RankRight ~ Order, var.equal=T)) # first in order 2
with(subset(Temp.TL, Item=='NextWeek' & AgeYears !='adult'), t.test(RankRight ~ Order, var.equal=T)) # first in order 1 -- better when tested last vs first
with(subset(Temp.TL, Item=='LastYear' & AgeYears !='adult'), t.test(RankRight ~ Order, var.equal=T)) # first in order 2

```

```{r calculate median timeline placements}

# calculate maximum placement distance for each timeline
MaxLinePlacements <- d.TL2 %>%
  group_by(subjid, linenum, agegroup, language) %>%
  summarize(n = n(),
            maxDistance = max(abs(distfrommid2)))

#d.TL2$subjid <- factor(d.TL2$subjid)

d.TL12<- merge(d.TL2, MaxLinePlacements, by = c("subjid", "linenum")) %>%
  mutate(Past = ifelse(item.stat == 0, "1", "0"))

d.TL12$signedScaledDist <- d.TL12$distfrommid2/d.TL12$maxDistance # divide each raw distance by the maximum distance an item was placed on the line
d.TL12$relOrd <- with(d.TL12, ifelse(Past == "1", abs(CorrectRank-3), CorrectRank-2)) # is it the first or the 2nd past item
#se <- function(x) sqrt(var(x) / length(x)) # function for calculating standard error

MedianPlacements <- d.TL12 %>%
  group_by(relOrd, Past, agegroup.x, language.x, item, linenum) %>%
  summarize(n = n(),
            medianlines = (median(signedScaledDist, na.rm = T)), # find median 
            medianlines_sd = (sd(signedScaledDist, na.rm = T)), # calculate standard deviation
            medianlines.se = medianlines_sd/sqrt(length(na.omit(signedScaledDist)))) # calculate standard error
  
library(plyr)
MedianPlacements$overallDeicticOrder <- as.ordered(as.character(mapvalues(MedianPlacements$item, c("lastyear", "lastbday", "lastweek", "beforeyesterday", "yesterday.3","yesterday.4", "thismorning","breakfast", "dinner", "tonight","tomorrow.2","tomorrow.4", "aftertomorrow", "nextweek","nextyear", "nextbday"), c(1,2,3,4,5,6,7,8,9,10,11,12, 13, 14, 15, 16))))
MedianPlacements$deicticSize <- 4 + as.numeric(MedianPlacements$overallDeicticOrder)
MedianPlacements$lineNames <- with(MedianPlacements, ifelse(linenum==1, "Events", ifelse(linenum== 2, "Deictic Terms 1", ifelse(linenum==3, "Deictic Terms 2","Deictic Terms 3"))))
MedianPlacements$AgeYears = with(MedianPlacements, factor(agegroup.x))

MedianPlacements2 <- MedianPlacements %>%
  mutate(item_recode = as.factor(case_when(linenum == 3 & item == "yesterday.3" ~ "yesterday",
                                 linenum == 4 & item == "yesterday.4" ~ "yesterday",
                                 linenum == 2 & item == "tomorrow.2" ~ "tomorrow",
                                 linenum == 4 & item == "tomorrow.4" ~ "tomorrow",
                                 item == "lastyear" ~ "lastyear",
                                 item == "lastweek" ~ "lastweek",
                                 item == "beforeyesterday" ~ "beforeyesterday",
                                 item == "thismorning" ~ "thismorning",
                                 item == "tonight" ~ "tonight",
                                 item == "aftertomorrow" ~ "aftertomorrow",
                                 item == "nextweek" ~ "nextweek",
                                 item == "nextyear" ~ "nextyear",
                                 item == "nextbday" ~ "nextbday",
                                 item == "lastbday" ~ "lastbday",
                                 item == "dinner" ~ "dinner",
                                 item == "breakfast" ~ "breakfast")))
adultLabels <- MedianPlacements2 %>%
  filter(AgeYears == "adult" & language.x == "german")

MedianPlacements2$newlineorder <- factor(MedianPlacements2$lineNames, levels = c("Events","Deictic Terms 1","Deictic Terms 2", "Deictic Terms 3"))

```

```{r plot median time placements in English}
  
timeline.endpoints2.english <- ggplot(subset(MedianPlacements2, language.x %in% c("english")), 
                              aes(x=AgeYears, y=medianlines, group=item, color=Past, fill=Past)) + 
  geom_ribbon(aes(ymin=medianlines-medianlines.se, ymax=medianlines+medianlines.se), alpha=.3) +
  geom_path(size=2) + 
  geom_point(aes(size=relOrd*3),size=8) +
  geom_segment(aes(y=0, yend=0, x=.9, xend=1.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=1.9, xend=2.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=2.9, xend=3.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=3.9, xend=4.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=4.9, xend=5.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=5.9, xend=6.1), linetype="solid", size=1, color="black") +
  geom_text(aes(label=item_recode), data = adultLabels, color="black", size=6, angle=25, nudge_x = .35, check_overlap = TRUE) + 
  facet_grid(~lineNames) +
  scale_color_discrete(name='', labels=c("future","past")) + 
  scale_fill_discrete(name='', labels=c("future","past")) + 
  scale_y_continuous(name="median location", limits=c(-1.24,1.24), breaks=c(0), labels=c("")) + 
  scale_x_discrete(name="age") + 
  theme_classic() + 
  theme(legend.position = "right",
        panel.grid.major.y = element_line(size=2, color="darkgrey"),
        panel.grid.major.x = element_line(size=0),
        panel.grid.minor.x = element_line(size=0),
        axis.text = element_text(size = rel(1.2)),
        axis.title = element_text(size = rel(2)),
        legend.text = element_text(size = rel(1.5)),
        strip.text = element_text(size = rel(1.5), face="bold"),
        strip.background = element_rect(fill = 'white', color="white"),
        panel.background = element_rect(color="white"),
        panel.border = element_blank(),
        # panel.margin = unit(8, "lines"),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  coord_flip()
timeline.endpoints2.english

ggsave("meantimelineplacements_english.jpeg", timeline.endpoints2.english, width = 20, height = 10)
```

```{r plot median time placements in German}
timeline.endpoints2.german <- ggplot(subset(MedianPlacements2, language.x %in% c("german")), 
                              aes(x=AgeYears, y=medianlines, group=item, color=Past, fill=Past)) + 
  geom_ribbon(aes(ymin=medianlines-medianlines.se, ymax=medianlines+medianlines.se), alpha=.3) +
  geom_path(size=2) + 
  geom_point(aes(size=relOrd*3),size=8) +
  geom_segment(aes(y=0, yend=0, x=.9, xend=1.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=1.9, xend=2.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=2.9, xend=3.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=3.9, xend=4.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=4.9, xend=5.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=5.9, xend=6.1), linetype="solid", size=1, color="black") +
  geom_text(aes(label=item_recode), data = adultLabels, stat = 'identity', nudge_x = .35, check_overlap = TRUE, na.rm = T, color="black", size=6, angle=25) + 
  facet_grid(~lineNames) +
  scale_color_discrete(name='', labels=c("future","past")) + 
  scale_fill_discrete(name='', labels=c("future","past")) + 
  scale_y_continuous(name="median location", limits=c(-1.24,1.24), breaks=c(0), labels=c("")) + 
  scale_x_discrete(name="age") + 
  theme_bw() + 
  theme(legend.position = "right",
        panel.grid.major.y = element_line(size=2, color="darkgrey"),
        panel.grid.major.x = element_line(size=0),
        panel.grid.minor.x = element_line(size=0),
        axis.text = element_text(size = rel(1.2)),
        axis.title = element_text(size = rel(2)),
        legend.text = element_text(size = rel(1.5)),
        strip.text = element_text(size = rel(1.5), face="bold"),
        strip.background = element_rect(fill = 'white', color="white"),
        panel.background = element_rect(color="white"),
        panel.border = element_blank(),
        # panel.margin = unit(8, "lines"),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  coord_flip()
timeline.endpoints2.german

ggsave("meantimelineplacements_german.jpeg", timeline.endpoints2.german, width = 20, height = 10)
```

```{r plot median placements collapsed across language groups}
# calculate maximum placement distance for each timeline
MaxLinePlacements <- d.TL2 %>%
  group_by(subjid, linenum, agegroup) %>%
  summarize(n = n(),
            maxDistance = max(abs(distfrommid2)))
#d.TL2$subjid <- factor(d.TL2$subjid)

d.TL12<- merge(d.TL2, MaxLinePlacements, by = c("subjid", "linenum")) %>%
  mutate(Past = ifelse(item.stat == 0, "1", "0"))

d.TL12$signedScaledDist <- d.TL12$distfrommid2/d.TL12$maxDistance # divide each raw distance by the maximum distance an item was placed on the line
d.TL12$relOrd <- with(d.TL12, ifelse(Past == "1", abs(CorrectRank-3), CorrectRank-2)) # is it the first or the 2nd past item
#se <- function(x) sqrt(var(x) / length(x)) # function for calculating standard error

MedianPlacements <- d.TL12 %>%
  group_by(relOrd, Past, agegroup.x, item, linenum) %>%
  summarize(n = n(),
            medianlines = (median(signedScaledDist, na.rm = T)), # find median 
            medianlines_sd = (sd(signedScaledDist, na.rm = T)), # calculate standard deviation
            medianlines.se = medianlines_sd/sqrt(length(na.omit(signedScaledDist)))) # calculate standard error
  
library(plyr)
MedianPlacements$overallDeicticOrder <- as.ordered(as.character(mapvalues(MedianPlacements$item, c("lastyear", "lastbday", "lastweek", "beforeyesterday", "yesterday.3","yesterday.4", "thismorning","breakfast", "dinner", "tonight","tomorrow.2","tomorrow.4", "aftertomorrow", "nextweek","nextyear", "nextbday"), c(1,2,3,4,5,6,7,8,9,10,11,12, 13, 14, 15, 16))))
MedianPlacements$deicticSize <- 4 + as.numeric(MedianPlacements$overallDeicticOrder)
MedianPlacements$lineNames <- with(MedianPlacements, ifelse(linenum==1, "Events", ifelse(linenum== 2, "Deictic Terms 1", ifelse(linenum==3, "Deictic Terms 2","Deictic Terms 3"))))
MedianPlacements$AgeYears = with(MedianPlacements, factor(agegroup.x))

MedianPlacements2 <- MedianPlacements %>%
  mutate(item_recode = as.factor(case_when(linenum == 3 & item == "yesterday.3" ~ "yesterday",
                                 linenum == 4 & item == "yesterday.4" ~ "yesterday",
                                 linenum == 2 & item == "tomorrow.2" ~ "tomorrow",
                                 linenum == 4 & item == "tomorrow.4" ~ "tomorrow",
                                 item == "lastyear" ~ "lastyear",
                                 item == "lastweek" ~ "lastweek",
                                 item == "beforeyesterday" ~ "beforeyesterday",
                                 item == "thismorning" ~ "thismorning",
                                 item == "tonight" ~ "tonight",
                                 item == "aftertomorrow" ~ "aftertomorrow",
                                 item == "nextweek" ~ "nextweek",
                                 item == "nextyear" ~ "nextyear",
                                 item == "nextbday" ~ "nextbday",
                                 item == "lastbday" ~ "lastbday",
                                 item == "dinner" ~ "dinner",
                                 item == "breakfast" ~ "breakfast")))
#adultLabels <- MedianPlacements2 %>%
  #filter(AgeYears == "adult")

MedianPlacements2$newlineorder <- factor(MedianPlacements2$lineNames, levels = c("Events","Deictic Terms 1","Deictic Terms 2", "Deictic Terms 3"))



timeline.endpoints2 <- ggplot(MedianPlacements2, 
                              aes(x=AgeYears, y=medianlines, group=item, color=Past, fill=Past)) + 
  geom_ribbon(aes(ymin=medianlines-medianlines.se, ymax=medianlines+medianlines.se), alpha=.3) +
  geom_path(size=2) + 
  geom_point(aes(size=relOrd*3),size=8) +
  geom_segment(aes(y=0, yend=0, x=.9, xend=1.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=1.9, xend=2.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=2.9, xend=3.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=3.9, xend=4.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=4.9, xend=5.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=5.9, xend=6.1), linetype="solid", size=1, color="black") +
  geom_text(aes(label=item_recode), data = adultLabels, color="black", size=6, angle=25, nudge_x = .35, check_overlap = TRUE) + 
  facet_grid(~lineNames) +
  scale_color_discrete(name='', labels=c("future","past")) + 
  scale_fill_discrete(name='', labels=c("future","past")) + 
  scale_y_continuous(name="median location", limits=c(-1.24,1.24), breaks=c(0), labels=c("")) + 
  scale_x_discrete(name="age") + 
  theme_classic() + 
  theme(legend.position = "right",
        panel.grid.major.y = element_line(size=2, color="darkgrey"),
        panel.grid.major.x = element_line(size=0),
        panel.grid.minor.x = element_line(size=0),
        axis.text = element_text(size = rel(1.2)),
        axis.title = element_text(size = rel(2)),
        legend.text = element_text(size = rel(1.5)),
        strip.text = element_text(size = rel(1.5), face="bold"),
        strip.background = element_rect(fill = 'white', color="white"),
        panel.background = element_rect(color="white"),
        panel.border = element_blank(),
        # panel.margin = unit(8, "lines"),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  coord_flip()
timeline.endpoints2

ggsave("meantimelineplacements.jpeg", timeline.endpoints2, width = 30, height = 10)
```

```{r plot median placements collapsed across language groups - Deictic 3 only}
# calculate maximum placement distance for each timeline
MaxLinePlacements <- d.TL2 %>%
  group_by(subjid, linenum, agegroup) %>%
  summarize(n = n(),
            maxDistance = max(abs(distfrommid2)))

#d.TL2$subjid <- factor(d.TL2$subjid)

d.TL12<- merge(d.TL2, MaxLinePlacements, by = c("subjid", "linenum")) %>%
  mutate(Past = ifelse(item.stat == 0, "1", "0"))

d.TL12$signedScaledDist <- d.TL12$distfrommid2/d.TL12$maxDistance # divide each raw distance by the maximum distance an item was placed on the line
d.TL12$relOrd <- with(d.TL12, ifelse(Past == "1", abs(CorrectRank-3), CorrectRank-2)) # is it the first or the 2nd past item
#se <- function(x) sqrt(var(x) / length(x)) # function for calculating standard error

MedianPlacements <- d.TL12 %>%
  group_by(relOrd, Past, agegroup.x, item, linenum) %>%
  summarize(n = n(),
            medianlines = (median(signedScaledDist, na.rm = T)), # find median 
            medianlines_sd = (sd(signedScaledDist, na.rm = T)), # calculate standard deviation
            medianlines.se = medianlines_sd/sqrt(length(na.omit(signedScaledDist)))) # calculate standard error
  
library(plyr)
MedianPlacements$overallDeicticOrder <- as.ordered(as.character(mapvalues(MedianPlacements$item, c("lastyear", "lastbday", "lastweek", "beforeyesterday", "yesterday.3","yesterday.4", "thismorning","breakfast", "dinner", "tonight","tomorrow.2","tomorrow.4", "aftertomorrow", "nextweek","nextyear", "nextbday"), c(1,2,3,4,5,6,7,8,9,10,11,12, 13, 14, 15, 16))))
MedianPlacements$deicticSize <- 4 + as.numeric(MedianPlacements$overallDeicticOrder)
MedianPlacements$lineNames <- with(MedianPlacements, ifelse(linenum==1, "Events", ifelse(linenum== 2, "Deictic Terms 1", ifelse(linenum==3, "Deictic Terms 2","Deictic Terms 3"))))
MedianPlacements$AgeYears = with(MedianPlacements, factor(agegroup.x))

MedianPlacements2 <- MedianPlacements %>%
  mutate(item_recode = as.factor(case_when(linenum == 3 & item == "yesterday.3" ~ "yesterday",
                                 linenum == 4 & item == "yesterday.4" ~ "yesterday",
                                 linenum == 2 & item == "tomorrow.2" ~ "tomorrow",
                                 linenum == 4 & item == "tomorrow.4" ~ "tomorrow",
                                 item == "lastyear" ~ "lastyear",
                                 item == "lastweek" ~ "lastweek",
                                 item == "beforeyesterday" ~ "beforeyesterday",
                                 item == "thismorning" ~ "thismorning",
                                 item == "tonight" ~ "tonight",
                                 item == "aftertomorrow" ~ "aftertomorrow",
                                 item == "nextweek" ~ "nextweek",
                                 item == "nextyear" ~ "nextyear",
                                 item == "nextbday" ~ "nextbday",
                                 item == "lastbday" ~ "lastbday",
                                 item == "dinner" ~ "dinner",
                                 item == "breakfast" ~ "breakfast")))


MedianPlacements2.Deictic3 <-  MedianPlacements2 %>%
  filter(linenum == 4)

adultLabels.Deictic3 <- MedianPlacements2.Deictic3 %>%
  filter(AgeYears == "adult")

timeline.endpoints2Deictic3 <- ggplot(MedianPlacements2.Deictic3, 
                              aes(x=AgeYears, y=medianlines, group=item, color=Past, fill=Past)) + 
  geom_ribbon(aes(ymin=medianlines-medianlines.se, ymax=medianlines+medianlines.se), alpha=.3) +
  geom_path(size=2) + 
  geom_point(aes(size=relOrd*3),size=8) +
  geom_segment(aes(y=0, yend=0, x=.9, xend=1.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=1.9, xend=2.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=2.9, xend=3.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=3.9, xend=4.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=4.9, xend=5.1), linetype="solid", size=1, color="black") + 
  geom_segment(aes(y=0, yend=0, x=5.9, xend=6.1), linetype="solid", size=1, color="black") +
  geom_text(aes(label=item), data = adultLabels.Deictic3, color="black", size=6, angle=25, nudge_x = .35, check_overlap = TRUE) + 
  scale_color_discrete(name='', labels=c("future","past")) + 
  scale_fill_discrete(name='', labels=c("future","past")) + 
  scale_y_continuous(name="median location", limits=c(-1.24,1.24), breaks=c(0), labels=c("")) + 
  scale_x_discrete(name="age") + 
  theme_classic() + 
  theme(legend.position = "right",
        panel.grid.major.y = element_line(size=2, color="darkgrey"),
        panel.grid.major.x = element_line(size=0),
        panel.grid.minor.x = element_line(size=0),
        axis.text = element_text(size = rel(1.2)),
        axis.title = element_text(size = rel(2)),
        legend.text = element_text(size = rel(1.5)),
        strip.text = element_text(size = rel(1.5), face="bold"),
        strip.background = element_rect(fill = 'white', color="white"),
        panel.background = element_rect(color="white"),
        panel.border = element_blank(),
        # panel.margin = unit(8, "lines"),
        axis.line = element_blank(),
        axis.ticks = element_blank()) +
  coord_flip()
timeline.endpoints2Deictic3

ggsave("meantimelineplacementsDeictic3.jpeg", timeline.endpoints2Deictic3, width = 8, height = 10)
```
