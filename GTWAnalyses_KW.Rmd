---
title: "GTW Analyses"
author: "KWilliams"
date: "`r Sys.Date()`"
output: html_document
---

################################################################# Load Packages ##################################################################

```{r, echo = FALSE}
library(tidyverse)
library(nloptr) #needed in order to call lme4
library(lme4)
library(ggplot2)
library(reshape2)
library(ggpubr)
library(dplyr)
library(rstatix)
library(car)
library(coin)
```

######################################################## Read in the  Data ################################################################

```{r}
d.g <- read.csv('german_12112019.csv')
d.g <- d.g %>%      
  select(-dob, -dot, -agedays, -agemonths, -monolingual, -comments, -X, -X.1, -X.2, -X.3, -X.4) %>% #remove unnecessary columns
  mutate(language = 'german',
        linenum = ifelse(item=="lastyear", 3, linenum)) # there appears to be an error where this item was incorrectly attributed to line 4

d.g[d.g == "999"] <- NA # Note that 999 indicates missing data
d.g[d.g == ""] <- NA # replace missing data and empty cells with NA

d.e <- read.csv('data_austin.csv')
d.e <- d.e %>%
  select(-ID,-dob, -dot, -agedays, -monolingual, -site, -covered, -comments, -experimenter) %>% # remove unnecessary columns
  mutate(language = 'english')

d.e[d.e == "999"] <- NA # Note that 999 indicates missing data
d.e[d.e == ""] <- NA # replace missing data and empty cells with NA


mutate(d.e, response = ifelse(itemtype == 'deictic' & is.na(response2) == T, response1,
                            ifelse(itemtype == 'verbal', response, response2))) # aggregate response1 and response2 columns for deictic items only
```

#################################################Some Data Management and wrangling#########################################################

```{r}
#Combine German and English data and fix typos in data entry and re-code weekday (1-7 corresponds to Sun-Sat)#
d.all <- rbind(d.g, d.e) %>% 
  mutate(item = as.factor(item),
         item = recode_factor(item, 'morning ' = 'thismorning',
                                      'twodaysago' = 'beforeyesterday', 
                                      'dayokweek' = 'daysofweek',
                                      'last year' = 'lastyear',
                                      'twofromnow' = 'aftertomorrow',
                                      'twoago' = 'beforeyesterday',
                                      'inaday' = 'tomorrow',
                                      'dayago' = 'yesterday',
                                      'onedayfromnow' = 'tomorrow',
                                      'thisevening' = 'tonight'),
        language = as.factor(language),
        itemnum = as.factor(itemnum),
        exclude = replace_na(exclude, 0))

d.all$weekday <- ifelse(d.all$weekday == "1", 7, ifelse(d.all$weekday == "2", 1, ifelse(d.all$weekday == "3", 2, ifelse(d.all$weekday == "4", 3, ifelse(d.all$weekday == "5", 4, ifelse(d.all$weekday == "6", 5, ifelse(d.all$weekday == "7", 6, 999)))))))
# weekday function in excel codes Sun-Sat as 1-7 so here I am re-coding so the variable levels match our calendar task (e.g., 1-7 from Mon-Sun)

d.all$weekday[d.all$weekday == "999"] <- NA # replace missing data with NA

future.words = c('aftertoday','aftertomorrow','dinner','nextbday','nextweek','nextyear','tomorrow','tonight') # Code all future time words
```

```{r}
#Code correct responses (to compare to 'correctr' variable)
d.all <- d.all %>%
  mutate(correctR = case_when(task == "calendar" & itemtype == "deictic" & item == "yesterday" ~ '3',
                              task == "calendar" & itemtype == "deictic" & item == "beforeyesterday" ~ '2',
                              task == "calendar" & itemtype == "deictic" & item == "tomorrow" ~ '5',
                              task == "calendar" & itemtype == "deictic" & item == "aftertomorrow" ~ '6',
                              task == "calendar" & itemtype == "verbal" & item == "aftertoday" ~ '1',
                              task == "calendar" & itemtype == "verbal" & item == "beforetoday" ~ '2',
                              task == "calendar" & itemtype == "verbal" & item == "daysofweek" ~ '7',
                              # assuming a 1 indicates that the child correctly identified all 7 days of the week
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "1" ~ "1",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "2" ~ "2",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "3" ~ "3",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "4" ~ "4",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "5" ~ "5",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "6" ~ "6",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "7" ~ "7",
                              # note that weekday values range from 1-7  (e.g.,Sunday = 1, Monday = 2, etc.)
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "1" ~ '7',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "2" ~ '1',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "3" ~ '2',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "4" ~ '3',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "5" ~ '4',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "6" ~ '5',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "7" ~ '6',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "1" ~ '2',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "2" ~ '3',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "3" ~ '4',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "4" ~ '5',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "5" ~ '6',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "6" ~ '7',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "7" ~ '1',
                              task == "timeline" & linenum == "1" & item == "lastbday" ~ '1',
                              task == "timeline" & linenum == "1" & item == "breakfast" ~ '2',
                              task == "timeline" & linenum == "1" & item == "dinner" ~ '3', 
                              task == "timeline" & linenum == "1" & item == "nextbday" ~ '4',
                              task == "timeline" & linenum == "2" & item == "lastweek" ~ '1',
                              task == "timeline" & linenum == "2" & item == "thismorning" ~ '2',
                              task == "timeline" & linenum == "2" & item == "tonight" ~ '3',
                              task == "timeline" & linenum == "2" & item == "tomorrow" ~ '4',
                              task == "timeline" & linenum == "3" & item == "lastyear" ~ '1',
                              task == "timeline" & linenum == "3" & item == "yesterday" ~ '2',
                              task == "timeline" & linenum == "3" & item == "nextweek" ~ '3',
                              task == "timeline" & linenum == "3" & item == "nextyear" ~ '4',
                              task == "timeline" & linenum == "4" & item == "beforeyesterday" ~ '1',
                              task == "timeline" & linenum == "4" & item == "yesterday" ~ '2',
                              task == "timeline" & linenum == "4" & item == "tomorrow" ~ '3',
                              task == "timeline" & linenum == "4" & item == "aftertomorrow" ~ '4'))
## seems to match correctr variable that already exists in the data file with two exceptions: verbal 'beforetoday' and 'aftertoday' are coded as indicated on the paper coding sheet e.g., 1 or 0.

check <- d.all %>%
  mutate(matchR = ifelse(correctr == correctR, 'YES', 'NO')) %>%
  filter(matchR == 'NO')   ## 74 mismatches, mostly on verbal Q's, in other cases correctR seems to be correct
```

Exclusions, change format of variables from factors to numeric and vice versa, create new variables to code correct responses and deictic status of responses on both the calendar and timeline task
```{r}
d.all <- d.all %>%
  filter(exclude==0) %>%
  mutate(response = as.numeric(response),
         correctR = as.numeric(correctR),
         order = as.factor(order),
         agegroup = as.factor(agegroup),
         linenum = as.factor(linenum),
         # create variable and code whether the item was placed in the correct rank (timeline task) or box (calendar task)
         correct = ifelse(response == correctR, 1, 0),
         # create variable to quantify how far the rank/box placement was from the correct rank/box
         dist.error = correctR - response,
         # create variable ignoring the direction of the error
         dist.error.a = abs(dist.error),
         # create variable and code whether the item's final placement was in the future (deictic status of response)
         resp.stat = case_when(task=='timeline' & distfrommid > 0 ~ 1,
                                 task=='calendar' & response > 4 ~ 1,
                                 task=='verbal' & item == 'today' & response > correctR ~ 1, 
                               TRUE ~ 0), # "what day will it be yesterday/today/tomorrow etc. e.g., Wednesday would be coded as 3"
         # create variable and code deictic status of the *first* sticker placement
         resp.stat.1 = case_when(task=='timeline' & distfrommid > 0 ~ 1,
                                 task=='calendar' & response1 > 4 ~ 1,
                                 task=='verbal' & item == 'today' & response1 > correctR ~ 1, 
                               TRUE ~ 0), 
         # create variable and code whether the item's correct placement is in the future
         item.stat = ifelse(item %in% future.words, 1, 0),
         # create variable and code whether the participant correctly placed the item in the past vs. future
         stat.correct = ifelse(item.stat == resp.stat, 1, 0),
         # create variable and code whether the deictic status of the first sticker placement was correct
         stat.correct.1 = ifelse(item.stat == resp.stat.1, 1, 0)) 
```

Participant counts
```{r}
subs <- d.all %>%
  select(subjid, agegroup, language) %>%
  group_by(agegroup, language) %>%
  distinct
subs_counts <- subs %>%
  group_by(agegroup, language) %>%
  summarize(n())
```

##################################################Calendar Task Analyses Begin Here##########################################################

```{r}
calv.d <- d.all %>% 
  filter(task == "calendar" & itemtype %in% c('deictic', 'verbal')) %>% #include all calendar items (verbal Qs too)
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

cal.d <- d.all %>% #create data frame that includes 3- to 7-year-olds
  filter(task=="calendar" & itemtype=="deictic") %>% # only select deictic calendar items (verbal items not involved in the calendar task)
 # filter(agegroup %in% c('4','5','6') & ageyears<7.0) %>% 
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))
cal.sum2 <- cal.d %>% # summarize data including 3- and 7-year-olds
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>% # for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(first.m = mean(cor.first, na.rm=T), # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic1.m = mean(stat.correct.1), # who got correct status (first answer)
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            rank.m = mean(correct), # right box (final answer)
            countCor.first = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram

cal.d2 <- d.all %>% # create new data frame and remove 3- and 7-year-olds
  filter(task=="calendar" & itemtype=="deictic" & agegroup %in% c('4','5','6') & ageyears<7.0) %>% # only select deictic calendar items
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

cal.sum <- cal.d2 %>% # summary of data frame excluding 3- and 7-year-olds
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>% #for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(first.m = mean(cor.first, na.rm=T), # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic1.m = mean(stat.correct.1), # % who got correct status (first answer)
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            rank.m = mean(correct), # % right box (final answer)
            countCor.first = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram
```

```{r}
# calculate percentage of trials in which kids of each age group got correct deictic status on calendar questions
cal.sum3 <- cal.d %>%
  group_by(agegroup) %>%
  summarize(n = n(),
            deictic1.m = (mean(stat.correct.1))*100, # who got correct status (first answer)
            deictic1.sd = (sd(stat.correct.1))*100, # standard deviation
            deictic1.se = deictic1.sd/sqrt(n), # calculate standard error
            deictic1.lower = deictic1.m - deictic1.se, # calculate lower 95% CI
            deictic1.upper = deictic1.m + deictic1.se) # calculate upper 95% CI
```

```{r}
cal.e <- cal.d %>% # filter english speakers only and create new data frame
  filter(language == "english") %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.g <- cal.d %>%
  filter(language == "german") %>% # filter german speakers only and create new data frame
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.d %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))
```

Calendar task only: Frequency distribution of box placement for each time word
```{r}
calhist.e <- cal.d %>% #filter english speakers and create new data frame
  filter(language == "english" & agegroup %in% c('4','5','6') & ageyears<7.0) %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

calhist.g <- cal.d %>% #filter german speakers and create new data frame
  filter(language == "german" & agegroup %in% c('4','5','6') & ageyears<7.0) %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

all <- ggplot(cal.d, aes(x = response1)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("box placement") +
  ggtitle("English Speakers") +
  ylim(0, 30) +
  facet_grid(language ~ item ~ agegroup)
all

calhist.e$agebin[calhist.e$agegroup == '4'] <- "Age 4"
calhist.e$agebin[calhist.e$agegroup == '5'] <- "Age 5"
calhist.e$agebin[calhist.e$agegroup == '6'] <- "Age 6"
calhist.g$agebin[calhist.g$agegroup == '4'] <- "Age 4"
calhist.g$agebin[calhist.g$agegroup == '5'] <- "Age 5"
calhist.g$agebin[calhist.g$agegroup == '6'] <- "Age 6"
  
# Frequency distributions of first response only
par(mfrow=c(1,1))
E <- ggplot(calhist.e, aes(x=response1)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("square placement") +
  ggtitle("English Speakers") +
  ylim(0, 40) +
  theme_classic() +
  facet_grid(item ~ agebin)

G <- ggplot(calhist.g, aes(x=response1)) +
  geom_histogram(fille="white", position ="identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("square placement") +
  ggtitle("German Speakers") +
  ylim(0, 40) +
  theme_classic() +
  facet_grid(item ~ agebin)

histograms <- ggarrange(E, G, 
          ncol = 2, nrow = 1)
ggsave(histograms, file= "BoxPlacementByItem.jpeg", width = 10, height = 5, dpi = 300)
```

```{r}
calhist.g <- calhist.g %>%
  mutate(ColorBar = case_when(item == "tomorrow" & response1 == 5 ~ "0",
                          item == "yesterday" & response1 ==  3 ~ "0",
                          item == "aftertomorrow" & response1 ==  6 ~ "0",
                          item == "beforeyesterday" & response1 ==  2 ~ "0")) # create new variable for filling correct placement

calhist.e <- calhist.e %>%
  mutate(ColorBar = case_when(item == "tomorrow" & response1 == 5 ~ "0",
                          item == "yesterday" & response1 ==  3 ~ "0",
                          item == "aftertomorrow" & response1 ==  6 ~ "0",
                          item == "beforeyesterday" & response1 ==  2 ~ "0"))

# recode Items for Facet Labels
calhist.g$Term[calhist.g$item == 'tomorrow'] <- "tomorrow"
calhist.g$Term[calhist.g$item == 'yesterday'] <- "yesterday"
calhist.g$Term[calhist.g$item == 'beforeyesterday'] <- "before-yesterday"
calhist.g$Term[calhist.g$item == 'aftertomorrow'] <- "after-tomorrow"
calhist.e$Term[calhist.e$item == 'tomorrow'] <- "tomorrow"
calhist.e$Term[calhist.e$item == 'yesterday'] <- "yesterday"
calhist.e$Term[calhist.e$item == 'beforeyesterday'] <- "before-yesterday"
calhist.e$Term[calhist.e$item == 'aftertomorrow'] <- "after-tomorrow"

English_SquarePlacements <- ggplot(calhist.e, aes(x = factor(response1), fill = ColorBar)) +
  geom_bar(color = "black") +
  scale_fill_brewer() +
  # scale_fill_grey(start = 0, end = 0.9) +
  theme_minimal(base_size = 10) +
  facet_grid(Term~agebin) +
  xlab("Square Placement") +
  ylab("Participant Count") +
  ylim(0, 35) +
  ggtitle("English Speakers (n = 113)") +
  theme(plot.title=element_text(family = "Times", color = "black", size = 10, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 10),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 10), 
        axis.title.x = element_text(family = "Times", color = "black", size = 10),
        axis.text.x = element_text(family = "Times", color = "black", size = 10)) +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                # panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black")) +
  theme(legend.position = "none") +
  # customize facet labels
  theme(
      strip.text.x = element_text(
        size = 10, color = "black", family = "Times"),
      strip.text.y = element_text(
        size = 10, color = "black", family = "Times")
      )

English_SquarePlacements

German_SquarePlacements <- ggplot(calhist.g, aes(x = factor(response1), fill = ColorBar)) +
  geom_bar(color = "black") +
  scale_fill_brewer() +
  theme_minimal(base_size = 10) +
  facet_grid(Term~agebin) +
  xlab("Square Placement") +
  ylab("") +
  ylim(0, 35) +
  ggtitle("German Speakers (n = 103)") +
  theme(plot.title=element_text(family = "Times", color = "black", size = 10, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 10),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 10), 
        axis.title.x = element_text(family = "Times", color = "black", size = 10),
        axis.text.x = element_text(family = "Times", color = "black", size = 10)) +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black")) +
  theme(legend.position = "none") +
  #customize facet labels
  theme(
      strip.text.x = element_text(
        size = 10, color = "black", family = "Times"),
      strip.text.y = element_text(
        size = 10, color = "black", family = "Times")
      )

German_SquarePlacements

Figure2 <- ggarrange(English_SquarePlacements, German_SquarePlacements, 
          ncol = 2, nrow = 1)

ggsave(Figure2, file= "Figure2.jpeg", width = 8, height = 5, dpi = 300)
```

Graph Correct First Placement (but show proportion of kids who placed sticker in each box)
```{r}
#exclude 3- and 7-year-olds from cal.sum4
cal.sum4 <- cal.d2 %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>%
  group_by(language, agegroup, item, response1) %>%
  summarize(n = n()) %>%
  mutate(freq = n/sum(n))
```

Calendar Task: does language spoken, item, or age (in years) predict successful placement of time words in the past or the future? [interaction term included in the model]
```{r}
d.lm1 <- glmer(stat.correct.1 ~ language*item*scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) #FTC
summary(d.lm1) 
Anova(d.lm1, Type=3) #suggests there is a main effect of age, but no main effects of language, item or interactions
```

Calendar Task: does language spoken, item, or age (in years) predict successful placement of time words in the past or the future? [interaction term removed from the model]
```{r}
d.lm2 <- glmer(stat.correct.1 ~ language + item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) 
summary(d.lm2)
Anova(d.lm2, Type=3) #main effect of age
```

Does age or item predict successful placement of time words in the past vs. the future within each language group separately? [no interaction term]
```{r}
d.lm.2e <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.e) 
summary(d.lm.2e)
Anova(d.lm.2e, Type=3) #main effect of age

d.lm.2g <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.g) 
summary(d.lm.2g)
Anova(d.lm.2g, Type=3) #main effect of age
```

Knowledge of deictic status on Calendar task: does language group, age, and temporal location (proximal vs. distal) predict successful placement of time words in the past or the future? [interaction term included in the model]
```{r}
d.lm3 <-  glmer(stat.correct.1 ~ language*prox*scale(ageyears) + (1|subjid), family='binomial', data=cal.d) #FTC
summary(d.lm3)
Anova(d.lm3, Type=3) # suggests there are no main effects of language, proximity, or age and no interactions
```

Knowledge of deictic status on Calendar task: does language group, age, and temporal location (proximal vs. distal) predict successful placement of time words in the past or the future? [interaction term removed from the model]
```{r}
d.lm4 <-  glmer(stat.correct.1 ~ language + prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.d) 
summary(d.lm4)
Anova(d.lm4, Type=3) #main effect of age
```

Knowledge of deictic status on calendar task: Does age or temporal location (proximal vs. distal) predict successful placement of time words in the past vs. the future within each langauge group separately? [no interaction term]
```{r}
d.lm.4e <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.e) 
summary(d.lm.4e)
Anova(d.lm.4e, Type=3) #main effect of age

d.lm.4g <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.g) 
summary(d.lm.4g)
Anova(d.lm.4g, Type=3) #main effect of age
```

Knowledge of precise meanings on calendar Task: does language spoken, item,  or age (in years) predict successful placement of time words in the correct squares on the first try? [interaction term included in the model]
```{r}
cal.lm1 <- glmer(cor.first ~ language*item*scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) #FTC
summary(cal.lm1) 
Anova(cal.lm1, Type=3) # suggests there are effects of language, item, and ageyears with no interactions
```

Knowledge of precise meanings on calendar Task: does language spoken, item,  or age (in years) predict successful placement of time words in the correct squares on the first try? [interaction term removed from the model]
```{r}
cal.lm2 <- glmer(cor.first ~ language + item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) 
summary(cal.lm2)
Anova(cal.lm2, Type=3)
```

Does age or item predict successful placement of time words in the correct square on the first try within each language group separately? [no interaction term]
```{r}
cal.lm.2e <- glmer(cor.first ~ item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.e) 
summary(cal.lm.2e)
Anova(cal.lm.2e, Type=3)

cal.lm.2g <- glmer(cor.first ~ item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.g) 
summary(cal.lm.2g)
Anova(cal.lm.2g, Type=3)
```

Wilcox_test for item level comparisons (cor.first) within each language group separately
```{r}
#filter by language & remove 3 and 7-year-olds
cal.e2 <- cal.e %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, cor.first)
  #mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.g2 <- cal.g %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, cor.first)
  #mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

#Wilcox_test for item level comparisons
English.test <- cal.e2 %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = cor.first ~ item, p.adjust.method = "BH") %>%
  add_significance()
English.test

German.test <- cal.g2 %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = cor.first ~ item, p.adjust.method = "BH") %>%
  add_significance()
German.test
```


Does language group, age, and temporal location (proximal vs. distal) predict correct placement? [interaction term included in the model]
```{r}
cal.lm3 <-  glmer(cor.first ~ language*prox*scale(ageyears) + (1|subjid), family='binomial', data=cal.d) #FTC
summary(cal.lm3)
Anova(cal.lm3, Type=3) # suggests there are no main effects of language, proximity, or age and no interactions
```

Does language group, age, and temporal location (proximal vs. distal) predict correct placement? [interaction term removed from the model]
```{r}
cal.lm4 <-  glmer(cor.first ~ language + prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.d) 
summary(cal.lm4)
Anova(cal.lm4, Type=3) #main effect of age
```

```{r}
#-language:prox:ageyears 
verbal <- d.all %>%
  filter(itemtype=="verbal" & agegroup %in% c('4','5') & item=="daysofweek") %>%
  group_by(language, item) %>%
  summarize(correct.m <- mean(correct))

### plot correct first placements (Did they give correct response first time)
correctPlacements <- ggplot(data=cal.sum, aes(x=agegroup, y=first.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
facet_wrap( ~ item, nrow=2) 
correctPlacements
ggsave(correctPlacements, file= "CorrectFirstPlacements.jpeg", width = 10, height = 10, dpi = 300)

#recode agegroup
cal.sum$agebin[cal.sum$agegroup == '4'] <- "Age 4"
cal.sum$agebin[cal.sum$agegroup == '5'] <- "Age 5"
cal.sum$agebin[cal.sum$agegroup == '6'] <- "Age 6"

#recode language spoken
cal.sum$languagegroup[cal.sum$language == 'english'] <- "English Speakers"
cal.sum$languagegroup[cal.sum$language == 'german'] <- "German Speakers"

#recode Item for Legend
cal.sum$Term[cal.sum$item == 'tomorrow'] <- "tomorrow"
cal.sum$Term[cal.sum$item == 'yesterday'] <- "yesterday"
cal.sum$Term[cal.sum$item == 'beforeyesterday'] <- "before-yesterday"
cal.sum$Term[cal.sum$item == 'aftertomorrow'] <- "after-tomorrow"

### plot correct first placements separately for each language group
Englishcal_sum <- cal.sum %>%
  filter(language == "english")
Germancal_sum <- cal.sum %>%
  filter(language == "german")

EnglishPlacements <- ggplot(data = Englishcal_sum, aes(x=agebin, y = first.m, group = Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers (n = 116)') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "bottom") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
EnglishPlacements

GermanPlacements <- ggplot(data=Germancal_sum, aes(x=agebin, y = first.m, group = Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('') +
  xlab('German Speakers (n = 103)') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
GermanPlacements

CorrectFirstFigure <- ggarrange(EnglishPlacements, GermanPlacements,
                    ncol = 2, nrow = 1, common.legend = TRUE, legend = "top")
CorrectFirstFigure

ggsave(CorrectFirstFigure, file= "BoxPlacementByItem2.jpeg",  width = 10, height = 5, dpi = 300)
```

```{r}
#exclude 3- and 7-year-olds from cal.sum (and collapse across language)
cal.sum3 <- cal.d2 %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>% #for each word, how many kids got them right on the first try
   group_by(agegroup, item) %>%
  summarize(first.m = mean(cor.first, na.rm=T),     # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic1.m = mean(stat.correct.1), # who got correct status (first answer)
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            rank.m = mean(correct), # right box (final answer)
            countCor.first = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram


#recode agegroup
cal.sum3$agebin[cal.sum3$agegroup == '4'] <- "Age 4"
cal.sum3$agebin[cal.sum3$agegroup == '5'] <- "Age 5"
cal.sum3$agebin[cal.sum3$agegroup == '6'] <- "Age 6"

#recode item for Legend
cal.sum3$Term[cal.sum3$item == 'tomorrow'] <- "tomorrow"
cal.sum3$Term[cal.sum3$item == 'yesterday'] <- "yesterday"
cal.sum3$Term[cal.sum3$item == 'beforeyesterday'] <- "before-yesterday"
cal.sum3$Term[cal.sum3$item == 'aftertomorrow'] <- "after-tomorrow"
  
### plot correct status collapsed across language group (CogSci Figure 3)
correctStatus <- ggplot(data=cal.sum3, 
                        aes(x=agebin, y=deictic1.m, group=Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = c(0.7, 0.2)) +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
          #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
correctStatus
ggsave(correctStatus, file= "correctStatus.jpeg", width = 5, height = 5, dpi = 300)
```


```{r}
### plot correct status
correctStatus <- ggplot(data=cal.sum, 
                        aes(x=agegroup, y=deictic1.m, group=Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('Proportion Correct') +
  ylim(0,1)
correctStatus
ggsave(correctStatus, file= "correctStatus.jpeg", width = 5, height = 5, dpi = 300)

### plot correct status by item (for each language separately)
EnglishStatus <- ggplot(data=Englishcal_sum, aes(x=agebin, y=deictic1.m, group=item, color=item)) +
  geom_line(aes(color=item))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
EnglishStatus

GermanStatus <-ggplot(data=Germancal_sum, aes(x=agebin, y=deictic1.m, group=item, color=item)) +
  geom_line(aes(color=item))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab ('German Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
GermanStatus

CorrectStatusFigure <- ggarrange(EnglishStatus, GermanStatus,
                    ncol = 2, nrow = 1, common.legend = TRUE, legend = "top")
CorrectStatusFigure

ggsave(CorrectStatusFigure, file="correctStatusFigure.jpeg", width = 10, height = 5, dpi = 300)

## check on bizarre results: English speaking older kids are doing worse with yesterday and tomorrow than the younger ones (not a problem anymore since we corrected the data files, yay!)
Englishcal_sum%>%
  group_by(item, agegroup) %>%
  summarize(mean(deictic.m))
cal.e %>%
  group_by(item, agegroup) %>%
  summarize(mean(stat.correct))
```

#check percentage of participants (in each language group separately) that were able to correctly recite the days of the week
```{r}
daysofweek <- d.all %>%
  select(-weekday, -ageyears, -order, -itemnum, -timelinefirst, -task, -linenum, -itemtype, -linelength, -distfrommid, -response2, -prompts, -item.stat, -stat.correct) %>%
  filter(item == "daysofweek")

German_daysofweek <- d.all %>%
  filter(language == "german", item == "daysofweek", exclude == "0") %>%
  select(subjid, agegroup, correct) %>%
  group_by(correct, agegroup) %>%
  summarise(n())

English_daysofweek <- d.all %>%
  filter(language == "english", item == "daysofweek", exclude == "0") %>%
  select(subjid, agegroup, correct) %>%
  group_by(correct, agegroup) %>%
  summarise(n())
```

##########################COGSCI PAPER ANALYSES END HERE##########################

##Did kids who answered verbal Qs correctly also answer Deictic Qs correctly?

```{r}
#create new data frame
target <- c("verbal", "deictic")
Calvd.d <- d.all %>%
  filter(task=="calendar" & itemtype == target) %>% # filter only calendar %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))
  select(-order, -linenum, -linelength, -distfrommid, -correctr, -timelinefirst, -itemnum) # make sure correctR is # accurately coded

Calvd.d$correct <- factor(Calvd.d$correct) #tell r to use correct as a factor variable
verbal.deictic <- glm(correct ~ itemtype, family = binomial(link='logit'), data=Calvd.d) #run logistic regression
summary(verbal.deictic)

Calv.dg <- Calvd.d %>% # filter out german participants only
  filter(language == "german")
German_VerbalQuestions <- ggplot(Calv.dg, aes(x = factor(correct))) +
  geom_bar(color = "black") +
  theme_minimal(base_size = 10) +
  facet_grid(itemtype~agegroup)
German_VerbalQuestions

German.test2 <- Calv.dg %>% # conduct Wilcox_test on english sample only
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
German.test2

Calv.de <- Calvd.d %>% # filter out english participants only
  filter(language == "english")
English_VerbalQuestions <- ggplot(Calv.de, aes(x = factor(correct))) +
  geom_bar(color = "black") +
  theme_minimal(base_size = 10) +
  facet_grid(itemtype~agegroup)
English_VerbalQuestions

English.test2 <- Calv.de %>% # conduct Wilcox_test on english sample only
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
English.test2
  
```
  
```{r}
verbal_items <- c("aftertoday", "beforetoday", "yesterday", "tomorrow", "today")

#calculate percentage of trials in which kids of each age group got verbal questions correct
verbal.sum <- Calvd.d %>%
  filter(itemtype == "verbal" & agegroup %in% c('4', '5', '6', '7') & item %in% c('aftertoday', 'beforetoday', 'yesterday', 'tomorrow', 'today')) %>% #filter only 5 verbal questions
  group_by(language, agegroup, item) %>%
  summarize(correct.m.v = mean(correct, na.rm=T), # % who answered correctly
            sd.correct.v = sd(correct, na.rm=T),
            n = n(),
            se.correct.v = sd.correct.v/sqrt(n),
            countCorrect.v = sum(correct, na.rm=T))  # sum proportion correct for making bar graph instead of histogram

deictic.sum <- Calvd.d %>%
  filter(itemtype == "deictic" & agegroup %in% c('4', '5', '6', '7')) %>%
  group_by(language, agegroup, item) %>%
  summarize(correct.m.d = mean(cor.first, na.rm=T), # % who answered correctly
            sd.correct.d = sd(cor.first, na.rm=T),
            n = n(),
            se.correct.d = sd.correct.d/sqrt(n),
            countCorrect.d = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram

sum.all <- rbind(verbal.sum, deictic.sum) # combine data into one data frame
sum.all.g <- sum.all %>%
  filter(language == "german")
sum.all.e <- sum.all %>%
  filter(language == "english")
```

##use verbal Q's to predict deictic Q's performance [split kids by if they recited days of week or not]
```{r}
Calv.d2 <- Calv.dg %>%
  filter(itemtype %in% c('verbal', 'deictic')) %>%
  select(subjid, agegroup, language, itemtype, item, response,correctR, correct)
Calv.d2T  <- reshape(Calv.d2, idvar = c("subjid", "agegroup"), timevar = "itemtype", direction = "wide")

Calv.d2T <- Calv.d2T %>%
  mutate(days_correct = case_when(item.verbal == "daysofweek" & correct.verbal == '1' ~ '1',
                                  item.verbal == "daysofweek" & correct.verbal == '0' ~ '0'))
```


````{r}
Calv.d2T$
Calvd.d.days <- Calvd.d %>%
  select_if(item == "daysofweek" & correct == 1) %>% # only select kids who
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))
  select(-order, -linenum, -linelength, -distfrommid, -correctr, -timelinefirst, -itemnum) # make sure correctR is # accurately coded








#create new data frame (verbal items only)
#German data only
#Calv.dg <- Calvd.d %>%
  #filter(itemtype == "verbal", language == "german") %>%
  #select (subjid, agegroup, item, correct, cor.first)
# create a new variable that sums up the # of verbal items correct
# transpose item (i.e., transform from long to wide format)
#Calv.dgT  <- reshape(Calv.dg, idvar = c("subjid", "agegroup"), timevar = "item", direction = "wide")
#Calv.dgT$verbal_score <-rowSums(Calv.dgT[,c("correct.beforetoday", "correct.yesterday")], na.rm = TRUE)

#English data only
#Calv.de <- Calvd.d %>%
  #filter(itemtype == "verbal", language == "english") %>%
  #select (subjid, agegroup, item, correct, cor.first)
#Calv.deT  <- reshape(Calv.de, idvar = c("subjid", "agegroup"), timevar = "item", direction = "wide")
#Calv.deT$verbal_score_corfirst <- rowSums(Calv.deT[,c("cor.first.beforetoday", "cor.first.yesterday")], na.rm = TRUE) 
#Calv.deT$verbal_score <-rowSums(Calv.deT[,c("correct.beforetoday", "correct.yesterday")], na.rm = TRUE)
```
#What are errors based on? distance from today?
#first.m = mean(cor.first, na.rm=T),     # average # of participants who put item in right box on first try
            #sd.correct = sd(cor.first, na.rm=T),
            #se.correct = sd.correct/sqrt(n),
            #deictic.m = mean(stat.correct), # average #participants who got correct status
            
###Did children place paired distal, proximal, past, and future items in the correct location? (e.g., correct placement for both tomorrow/after tomorrow)
```{r}
#create new data frame
cal.allT <- cal.d %>%
  select (subjid, agegroup, language, item, correct)
#transpose item (i.e., transform from long to wide format)
cal.allT <- reshape(cal.allT, idvar = c("subjid", "agegroup", "language"), timevar = "item", direction = "wide")

#Code for tomorrow & yesterday both correct (proxCorr = 1)
cal.allT <- cal.allT %>%
  mutate(proxCorr = case_when(correct.tomorrow == "1" & correct.yesterday == "1" ~ 1, TRUE ~ 0)) %>%
#Code for after tomorrow & before yesterday both correct (distCorr = 1)
  mutate(distCorr = case_when(correct.aftertomorrow == "1" & correct.beforeyesterday == "1" ~ 1, TRUE ~ 0)) %>%
#Code for tomorrow & after tomorrow correct (tomorrow2Corr = 1)
  mutate(tomorrow2Corr = case_when(correct.tomorrow == "1" & correct.aftertomorrow == "1" ~ 1, TRUE ~ 0)) %>%
#Code for yesterday & before yesterday correct (yesterday2Corr = 1)
  mutate(yesterday2Corr = case_when(correct.yesterday == "1" & correct.beforeyesterday == "1" ~ 1, TRUE ~ 0))

#create new data frame (again) and transpose from wide format back to long format
cal.allTrecoded <- cal.allT %>%
  select(subjid, agegroup, language, proxCorr, distCorr, tomorrow2Corr, yesterday2Corr)
cal.allTrecoded <- reshape(cal.allTrecoded,
                           idvar = "subjid", 
                           varying = list(c(4, 5, 6, 7)), 
                           direction = "long", 
                           v.names = c('BothCorr'), 
                           timevar = "Pair")
#rename values in 'Pair' variable column
cal.allTrecoded <- cal.allTrecoded %>%
  mutate(Pair = as.factor(Pair), 
         item = recode_factor(Pair, '1' = 'proxCorr', 
                              '2' = 'distCorr', 
                              '3' = 'tomorrow2Corr', 
                              '4' = 'yesterday2Corr'))

#counts just to make sure data was transposed correctly (without error)
#counts for wide data frame (English Ps only)
#proxCorr_countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, proxCorr) %>%
  #summarise(Freq=n())
#distCorr_countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup,distCorr) %>%
  #summarise(Freq=n())
#tomorrow2Corr.countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, tomorrow2Corr) %>%
  #summarise(Freq=n())
#yesterday2Corr.countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, yesterday2Corr) %>%
  #summarise(Freq=n())

#counts for long data frame
#proxCorr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "proxCorr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#distCorr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "distCorr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#tomorrow2corr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "tomorrow2Corr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#yesterday2Corr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "yesterday2Corr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())

###plot number of participants who answered pairs of questions correctly: distal Qs, proximal Qs, tomorrow/after tomorrow Qs, yesterday/before yesterday Qs.
ggplot(cal.allTrecoded, aes(x=BothCorr)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 0.5) +
  xlab("1 = both correct") +
  facet_grid(item ~ agegroup)
ggplot(data=cal.allTrecoded, aes(x = BothCorr)) +
  geom_bar() +
  geom_text(stat='count', aes(label = ..count..), vjust = -1) +
  facet_wrap(language ~ item, nrow = 4)

###plot proportion of participants who answered pairs of questions correctly: distal Qs, proximal Qs, tomorrow Qs, yesterday Qs.
##1 = both correct, 0 = one or more incorrect responses for paired stimuli (e.g., tomorrow & day after tomorrow)
cal.allTrecoded[,'BothCorrF'] <- as.factor(cal.allTrecoded[,'BothCorr'])
Prop_Graph <- ggplot(cal.allTrecoded, aes(x=item, fill = BothCorrF)) +
  geom_bar(position = "fill") +
  coord_flip() +
  ylab('proportion of participants') +
  facet_wrap(language ~ agegroup)


cal.sumPairs <- cal.allTrecoded %>%
#for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(bothcorrect.m = mean(BothCorr, na.rm=T),     # % who put item in right box on first try
            sd.bothcorrect = sd(BothCorr, na.rm=T),
            n = n(),
            se.bothcorrect = sd.bothcorrect/sqrt(n))

### plot if paired items both correct (correct response first time)
CorrectPairs <- ggplot(data=cal.sumPairs, aes(x=agegroup, y=bothcorrect.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
facet_wrap( ~ item, nrow=2) 
CorrectPairs

ggsave(CorrectPairs, file= "PairedItems_PropCorrect.jpeg", width = 10, height = 10, dpi = 300)

#plot if paired items both placed correctly on the first try (for each language separately)
Englishcal.sumPairs <- cal.sumPairs %>%
  filter(language == "english")

Germancal.sumPairs <- cal.sumPairs %>%
  filter(language == "german")

CorrectPairsEnglish <- ggplot(data=Englishcal.sumPairs, aes(x = agegroup, y =bothcorrect.m, group=item, color=item)) +
  geom_line(aes(color = item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0, 1)
CorrectPairsEnglish

CorrectPairsGerman <- ggplot(data=Germancal.sumPairs, aes(x = agegroup, y =bothcorrect.m, group=item, color=item)) +
  geom_line(aes(color = item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0, 1)

CorrectPairsFigure <- ggarrange(CorrectPairsEnglish, CorrectPairsGerman,
                    labels = c("English", "German"),
                    ncol = 2, nrow = 1)
CorrectPairsFigure
```

```{r}
#compare performance between time words (within each language separately)
ggboxplot(Englishcal_sum, x = "item", y = "first.m",
          color = "item",
          ylab = "% who put item in right box on first try", xlab = "items", 
          ylim=c(0.2, 1.0)) +
  ggtitle("English Speakers")

ggboxplot(Germancal_sum, x = "item", y = "first.m",
          color = "item",
          ylab = "% who put item in right box on first try", xlab = "items", 
          ylim=c(0.2, 1.0)) +
  ggtitle("German Speakers")
```

```{r}
#compare performance between time words by age group (within each language separately)
English_boxplot <- ggboxplot(Englishcal_sum, x = "item", y = "first.m",
          color = "item", 
          ylab = "% who put item in right box on first try", xlab = "items",
          ylim=c(0, 1.0),
          facet.by = "agegroup",
          nrow = 3,
          ncol = 1) +
  ggtitle("English Speakers")
English_boxplot
ggsave(English_boxplot, file= "EnglishBoxPlot.jpeg", width = 12, height = 10, dpi = 300)

German_boxplot <- ggboxplot(Germancal_sum, x = "item", y = "first.m",
          color = "item", 
          ylab = "% who put item in right box on first try", xlab = "items",
          ylim=c(0, 1.0),
          facet.by = "agegroup",
          nrow = 3,
          ncol = 1) +
  ggtitle("German Speakers")
German_boxplot
ggsave(German_boxplot, file= "GermanBoxPlot.jpeg", width = 12, height = 10, dpi = 300)
```


#Mixed-effects logistic regression examining the effects of age, and verbal Qs on childrens successful placement of time words in the correct squares on the first try
```{r}
#create new data frame (english only)
#vd.e <- d.all %>%
  #filter(language == 'english', task=="calendar" & itemtype %in% c("deictic", "verbal") & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  #select(-linelength,-distfrommid) %>%
  #mutate(#response = ifelse(is.na(response2) == T, response1, response2), #this is redundant
         #response = as.numeric(response), #this is redundant 
         #cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         #prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), #yesterday and tomorrow coded as proximal terms
         #prox = as.factor(prox))

#English participants only
#vd.lm.e = glmer(correct ~ itemtype*ageyears + (1|subjid), family='binomial', data=vd.e)
#summary(vd.lm.e)

#create new data frame (german only)
#vd.g <- d.all %>%
   #filter(language == 'german', task=="calendar" & itemtype %in% c("deictic", "verbal") & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  #select(-linelength,-distfrommid) %>%
  #mutate(#response = ifelse(is.na(response2) == T, response1, response2), #this is redundant
         #response = as.numeric(response), #this is redundant 
         #cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         #prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), #yesterday and tomorrow coded as proximal terms
         #prox = as.factor(prox))
#German participants only
#vd.lm.g = glmer(cor.first ~ itemtype + ageyears + (1|subjid), family='binomial', data=vd.g)
#summary(vd.lm.g)
```

##Sum # of words correct (4 correct? 3 correct? etc.)
