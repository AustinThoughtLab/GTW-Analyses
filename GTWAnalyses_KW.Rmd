---
title: "GTW Analyses"
author: "KWilliams"
date: "`r Sys.Date()`"
output: html_document
---

################################################################# Load Packages ##################################################################

```{r, echo = FALSE}
library(tidyverse) # for reshaping data
library(nloptr) # for calling lme4
library(lme4)
library(ggplot2) # plotting data
library(reshape2)
library(ggpubr)
library(dplyr) # for data manipulation
library(rstatix)
library(car)
library(coin)
library(scales)  # for scale_y_continuous(label = percent)
library(psych) # for calculating ICC reliability check on timeline task
library(ggthemes) # for scale_fill_few('medium')
```

# Read in the  Data

```{r}
d.g <- read.csv('german_12112019.csv')
d.g <- d.g %>%      
  select(-dob, -dot, -agedays, -agemonths, -monolingual, -comments, -X, -X.1, -X.2, -X.3, -X.4) %>% # remove unnecessary columns
  mutate(language = 'german',
        linenum = ifelse(item=="lastyear", 3, linenum)) # there appears to be an error where this item was incorrectly attributed to line 4

d.g[d.g == "999"] <- NA # Note that 999 indicates missing data
d.g[d.g == ""] <- NA # replace missing data and empty cells with NA

d.e <- read.csv('data_austin.csv')
d.e <- d.e %>%
  select(-ID,-dob, -dot, -agedays, -monolingual, -site, -covered, -comments, -experimenter) %>% # remove unnecessary columns
  mutate(language = 'english')

d.e[d.e == "999"] <- NA # Note that 999 indicates missing data
d.e[d.e == ""] <- NA # replace missing data and empty cells with NA


d.e <- mutate(d.e, response = ifelse(itemtype == 'deictic' & is.na(response2) == T, response1,
                            ifelse(itemtype == 'verbal', response, response2))) # aggregate response1 and response2 columns for deictic items only

d.g <- mutate(d.g, response = ifelse(itemtype %in% c('deictic', 'event') & is.na(response2) == T, response1, 
                              ifelse(itemtype == 'verbal', response1, response2)))
```

# Some Data Management and wrangling

```{r}
# Combine German and English data and fix typos in data entry and re-code weekday (1-7 corresponds to Sun-Sat)#
d.all <- rbind(d.g, d.e) %>% 
  mutate(item = as.factor(item),
         item = recode_factor(item, 'morning ' = 'thismorning',
                                      'twodaysago' = 'beforeyesterday', 
                                      'dayokweek' = 'daysofweek',
                                      'last year' = 'lastyear',
                                      'twofromnow' = 'aftertomorrow',
                                      'twoago' = 'beforeyesterday',
                                      'inaday' = 'tomorrow',
                                      'dayago' = 'yesterday',
                                      'onedayfromnow' = 'tomorrow',
                                      'thisevening' = 'tonight'),
         weekday = as.factor(weekday),
         weekday = recode_factor(weekday, '1' = '7',
                                 '2' = '1',
                                 '3' = '2',
                                 '4' = '3',
                                 '5' = '4',
                                 '6' = '5',
                                 '7' = '6'), # recode default weekday function in excel to match calendar task (e.g., 1-7)
        distfrommid = distfrommid_c1, # _c1/_c2 for ICC but for main analyses use distfrommid to avoid confusion
        language = as.factor(language),
        itemnum = as.factor(itemnum),
        exclude = replace_na(exclude, 0))

future.words = c('aftertoday','aftertomorrow','dinner','nextbday','nextweek','nextyear','tomorrow','tonight') # Code all future time words
```

```{r}
# Code correct responses (to compare to 'correctr' variable)
d.all <- d.all %>%
  mutate(correctR = case_when(task == "calendar" & itemtype == "deictic" & item == "yesterday" ~ '3',
                              task == "calendar" & itemtype == "deictic" & item == "beforeyesterday" ~ '2',
                              task == "calendar" & itemtype == "deictic" & item == "tomorrow" ~ '5',
                              task == "calendar" & itemtype == "deictic" & item == "aftertomorrow" ~ '6',
                              task == "calendar" & itemtype == "verbal" & item == "aftertoday" ~ '1',
                              task == "calendar" & itemtype == "verbal" & item == "beforetoday" ~ '2',
                              task == "calendar" & itemtype == "verbal" & item == "daysofweek" ~ '7',
                              # assuming a 1 indicates that the child correctly identified all 7 days of the week
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "1" ~ "1",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "2" ~ "2",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "3" ~ "3",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "4" ~ "4",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "5" ~ "5",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "6" ~ "6",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "7" ~ "7",
                              # note that weekday values range from 1-7  (e.g.,Sunday = 1, Monday = 2, etc.)
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "1" ~ '7',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "2" ~ '1',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "3" ~ '2',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "4" ~ '3',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "5" ~ '4',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "6" ~ '5',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "7" ~ '6',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "1" ~ '2',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "2" ~ '3',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "3" ~ '4',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "4" ~ '5',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "5" ~ '6',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "6" ~ '7',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "7" ~ '1',
                              task == "timeline" & linenum == "1" & item == "lastbday" ~ '1',
                              task == "timeline" & linenum == "1" & item == "breakfast" ~ '2',
                              task == "timeline" & linenum == "1" & item == "dinner" ~ '3', 
                              task == "timeline" & linenum == "1" & item == "nextbday" ~ '4',
                              task == "timeline" & linenum == "2" & item == "lastweek" ~ '1',
                              task == "timeline" & linenum == "2" & item == "thismorning" ~ '2',
                              task == "timeline" & linenum == "2" & item == "tonight" ~ '3',
                              task == "timeline" & linenum == "2" & item == "tomorrow" ~ '4',
                              task == "timeline" & linenum == "3" & item == "lastyear" ~ '1',
                              task == "timeline" & linenum == "3" & item == "yesterday" ~ '2',
                              task == "timeline" & linenum == "3" & item == "nextweek" ~ '3',
                              task == "timeline" & linenum == "3" & item == "nextyear" ~ '4',
                              task == "timeline" & linenum == "4" & item == "beforeyesterday" ~ '1',
                              task == "timeline" & linenum == "4" & item == "yesterday" ~ '2',
                              task == "timeline" & linenum == "4" & item == "tomorrow" ~ '3',
                              task == "timeline" & linenum == "4" & item == "aftertomorrow" ~ '4'))
## seems to match correctr variable that already exists in the data file with two exceptions: verbal 'beforetoday' and 'aftertoday' are coded as indicated on the paper coding sheet e.g., 1 or 0.

check <- d.all %>%
  mutate(matchR = ifelse(correctr == correctR, 'YES', 'NO')) %>%
  filter(matchR == 'NO')   ## 74 mismatches, mostly on verbal Q's, in other cases correctR seems to be correct
```

# Exclusions, change format of variables from factors to numeric and vice versa, create new variables to code correct responses and deictic status of responses on both the calendar and timeline task
```{r}
d.all <- d.all %>%
  filter(exclude==0) %>%
  mutate(response = as.numeric(response),
         correctR = as.numeric(correctR),
         order = as.factor(order),
         agegroup = as.factor(agegroup),
         linenum = as.factor(linenum),
         # create variable and code whether the item was placed in the correct rank (timeline task) or box (calendar task)
         correct = ifelse(response == correctR, 1, 0),
         # create variable to quantify how far the rank/box placement was from the correct rank/box
         dist.error = correctR - response,
         # create variable ignoring the direction of the error
         dist.error.a = abs(dist.error),
         # create variable and code whether the item's final placement was in the future (deictic status of response)
         resp.stat = case_when(task=='timeline' & distfrommid > 0 ~ 1,
                                 task=='calendar' & response > 4 ~ 1,
                                 task=='verbal' & item == 'today' & response > correctR ~ 1, 
                               TRUE ~ 0), # "what day will it be yesterday/today/tomorrow etc. e.g., Wednesday would be coded as 3"
         # create variable and code deictic status of the *first* sticker placement and drawn location on the lineline
         resp.stat.1 = case_when(task=='timeline' & distfrommid > 0 ~ 1,
                                 task=='calendar' & response1 > 4 ~ 1,
                                 task=='verbal' & item == 'today' & response1 > correctR ~ 1, 
                               TRUE ~ 0),
         # create variable and code whether the item's correct placement is in the future
         item.stat = ifelse(item %in% future.words, 1, 0),
         # create variable and code whether the participant correctly placed the item in the past vs. future
         stat.correct = ifelse(item.stat == resp.stat, 1, 0),
         # create variable and code whether the deictic status of the first sticker placement was correct
         stat.correct.1 = ifelse(item.stat == resp.stat.1, 1, 0))
```

Create new variables to code correct remoteness status of responses on the calendar and timeline tasks:
1. calculate response remoteness on calendar task: abs(response placement - location of 'today'))
2. code correct remoteness on calendar task: 1 = yesterday/tomorrow; 2 = beforeyesterday/aftertomorrow
3. calculate response remoteness on teimeline task: Rank 1 = -7 < x < -3.5; Rank 2 = -3.5 < x < 0; Rank 3 = 0 < x < 3.5; Rank 4 = 3.5 < x < 7
4. calculate correct remoteness on timeline task: if response remoteness falls within appropriate numerical range
```{r}
d.all <- d.all %>%
  # create a variable to quantify how far the rank/box placement was from 'today'
  mutate(resp.remoteness = case_when(task == 'calendar' & itemtype == 'deictic' ~ abs(response - 4))) %>% 
  # create new variable to code if response remoteness was correct for all items on the calendar and timeline tasks
  mutate(cor.remote = case_when(task == "calendar" & itemtype == "deictic" & resp.remoteness == abs(correctR - 4) ~ '1',
                                task == "timeline" & linenum == "1" & item == "lastbday" & between(distfrommid, -7, -3.5) ~ '1',
                                task == "timeline" & linenum == "1" & item == "breakfast" & between(distfrommid, -3.5, 0) ~ '1',
                                task == "timeline" & linenum == "1" & item == "dinner" & between(distfrommid, 0, 3.5) ~ '1', 
                                task == "timeline" & linenum == "1" & item == "nextbday" & between(distfrommid, 3.5, 7) ~ '1',
                                task == "timeline" & linenum == "2" & item == "lastweek" & between(distfrommid, -7, -3.5) ~ '1',
                                task == "timeline" & linenum == "2" & item == "thismorning" & between(distfrommid, -3.5, 0) ~ '1',
                                task == "timeline" & linenum == "2" & item == "tonight" & between(distfrommid, 0, 3.5) ~ '1',
                                task == "timeline" & linenum == "2" & item == "tomorrow" & between(distfrommid, 3.5, 7) ~ '1',
                                task == "timeline" & linenum == "3" & item == "lastyear" & between(distfrommid, -7, -3.5) ~ '1',
                                task == "timeline" & linenum == "3" & item == "yesterday" & between(distfrommid, -3.5, 0) ~ '1',
                                task == "timeline" & linenum == "3" & item == "nextweek" & between(distfrommid, 0, 3.5) ~ '1',
                                task == "timeline" & linenum == "3" & item == "nextyear" & between(distfrommid, 3.5, 7) ~ '1',
                                task == "timeline" & linenum == "4" & item == "beforeyesterday" & between(distfrommid, -7, -3.5) ~ '1',
                                task == "timeline" & linenum == "4" & item == "yesterday" & between(distfrommid, -3.5, 0) ~ '1',
                                task == "timeline" & linenum == "4" & item == "tomorrow" & between(distfrommid, 0, 3.5) ~ '1',
                                task == "timeline" & linenum == "4" & item == "aftertomorrow" & between(distfrommid, 3.5, 7) ~ '1'),
         cor.remote = case_when(cor.remote == NA ~ '0'),
         cor.remote = as.numeric(cor.remote))

# d.all$cor.remote[is.na(d.all$cor.remote) == T] <- '0' # replace missing data with 0
# d.all$cor.remote <- as.numeric(d.all$cor.remote) # convert from character length to numeric variable
```

Participant counts
```{r}
subs <- d.all %>%
  select(subjid, agegroup, language) %>%
  group_by(agegroup, language) %>%
  distinct
subs_counts <- subs %>%
  group_by(agegroup, language) %>%
  summarize(n())
```

# Calendar Task Analyses Begin Here

```{r}
calv.d <- d.all %>% 
  filter(task == "calendar" & itemtype %in% c('deictic', 'verbal')) %>% #include all calendar items (verbal Qs too)
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

cal.d <- d.all %>% #create data frame that includes 3- to 7-year-olds
  filter(task=="calendar" & itemtype=="deictic") %>% # only select deictic calendar items (verbal items not involved in the calendar task)
 # filter(agegroup %in% c('4','5','6') & ageyears<7.0) %>% 
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

cal.sum2 <- cal.d %>% # summarize data including 3- and 7-year-olds
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>% # for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(first.m = mean(cor.first, na.rm=T), # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic1.m = mean(stat.correct.1), # who got correct status (first answer)
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            rank.m = mean(correct), # right box (final answer)
            countCor.first = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram

cal.d2 <- d.all %>% # create new data frame and remove 3- and 7-year-olds
  filter(task=="calendar" & itemtype=="deictic" & agegroup %in% c('4','5','6') & ageyears<7.0) %>% # only select deictic calendar items
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

cal.sum <- cal.d2 %>% # summary of data frame excluding 3- and 7-year-olds
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow")),
         prox = case_when(item == 'beforeyesterday' ~ 'Distal Terms',
                          item == 'aftertomorrow' ~ 'Distal Terms',
                          item == 'yesterday' ~ 'Proximal Terms',
                          item == 'tomorrow' ~ 'Proximal Terms')) %>%
  group_by(language, agegroup, item, prox) %>%
  summarize(first.m = mean(cor.first, na.rm=T), # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic1.m = mean(stat.correct.1), # % who got correct status (first answer)
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            remoteness.m = mean(cor.remote), # % who got correct remoteness
            rank.m = mean(correct), # % right box (final answer)
            countCor.first = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram
```

```{r}
# calculate percentage of trials kids of each age group responded with correct deictic status on calendar questions
cal.sum3 <- cal.d %>%
  group_by(agegroup) %>%
  summarize(n = n(),
            deictic1.m = (mean(stat.correct.1))*100, # who got correct status (first answer)
            deictic1.sd = (sd(stat.correct.1))*100, # standard deviation
            deictic1.se = deictic1.sd/sqrt(n), # calculate standard error
            deictic1.lower = deictic1.m - deictic1.se, # calculate lower 95% CI
            deictic1.upper = deictic1.m + deictic1.se) # calculate upper 95% CI

# calculate percentage of trials in which kids of each age group responded with correct remoteness on calendar questions
cal.sum5 <- cal.d %>%
  group_by(agegroup) %>%
  summarize(n = n(),
            remoteness.m = (mean(cor.remote))*100, # who got correct status (first answer)
            remoteness.sd = (sd(cor.remote))*100, # standard deviation
            remoteness.se = remoteness.sd/sqrt(n), # calculate standard error
            remoteness.lower = remoteness.m - remoteness.se, # calculate lower 95% CI
            remoteness.upper = remoteness.m + remoteness.se) # calculate upper 95% CI
```

```{r}
cal.e <- cal.d %>% # filter english speakers only and create new data frame
  filter(language == "english") %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.g <- cal.d %>%
  filter(language == "german") %>% # filter german speakers only and create new data frame
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.d %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))
```

Calendar task only: Frequency distribution of box placement for each time word
```{r}
calhist.e <- cal.d %>% #filter english speakers and create new data frame
  filter(language == "english" & agegroup %in% c('4','5','6') & ageyears<7.0) %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

calhist.g <- cal.d %>% #filter german speakers and create new data frame
  filter(language == "german" & agegroup %in% c('4','5','6') & ageyears<7.0) %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

all <- ggplot(cal.d, aes(x = response1)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("box placement") +
  ggtitle("English Speakers") +
  ylim(0, 30) +
  facet_grid(language ~ item ~ agegroup)
all

calhist.e$agebin[calhist.e$agegroup == '4'] <- "Age 4"
calhist.e$agebin[calhist.e$agegroup == '5'] <- "Age 5"
calhist.e$agebin[calhist.e$agegroup == '6'] <- "Age 6"
calhist.g$agebin[calhist.g$agegroup == '4'] <- "Age 4"
calhist.g$agebin[calhist.g$agegroup == '5'] <- "Age 5"
calhist.g$agebin[calhist.g$agegroup == '6'] <- "Age 6"
  
# Frequency distributions of first response only
par(mfrow=c(1,1))
E <- ggplot(calhist.e, aes(x=response1)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("square placement") +
  ggtitle("English Speakers") +
  ylim(0, 40) +
  theme_classic() +
  facet_grid(item ~ agebin)

G <- ggplot(calhist.g, aes(x=response1)) +
  geom_histogram(fill="white", position ="identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("square placement") +
  ggtitle("German Speakers") +
  ylim(0, 40) +
  theme_classic() +
  facet_grid(item ~ agebin)

histograms <- ggarrange(E, G, 
          ncol = 2, nrow = 1)
ggsave(histograms, file= "BoxPlacementByItem.jpeg", width = 10, height = 5, dpi = 300)
```

```{r}
calhist.g <- calhist.g %>%
  mutate(ColorBar = case_when(item == "tomorrow" & response1 == 5 ~ "0",
                          item == "yesterday" & response1 ==  3 ~ "0",
                          item == "aftertomorrow" & response1 ==  6 ~ "0",
                          item == "beforeyesterday" & response1 ==  2 ~ "0")) # create new variable for filling correct placement

calhist.e <- calhist.e %>%
  mutate(ColorBar = case_when(item == "tomorrow" & response1 == 5 ~ "0",
                          item == "yesterday" & response1 ==  3 ~ "0",
                          item == "aftertomorrow" & response1 ==  6 ~ "0",
                          item == "beforeyesterday" & response1 ==  2 ~ "0"))

# recode Items for Facet Labels
calhist.g$Term[calhist.g$item == 'tomorrow'] <- "tomorrow"
calhist.g$Term[calhist.g$item == 'yesterday'] <- "yesterday"
calhist.g$Term[calhist.g$item == 'beforeyesterday'] <- "before-yesterday"
calhist.g$Term[calhist.g$item == 'aftertomorrow'] <- "after-tomorrow"
calhist.e$Term[calhist.e$item == 'tomorrow'] <- "tomorrow"
calhist.e$Term[calhist.e$item == 'yesterday'] <- "yesterday"
calhist.e$Term[calhist.e$item == 'beforeyesterday'] <- "before-yesterday"
calhist.e$Term[calhist.e$item == 'aftertomorrow'] <- "after-tomorrow"

English_SquarePlacements <- ggplot(calhist.e, aes(x = factor(response1), fill = ColorBar)) +
  geom_bar(color = "black") +
  scale_fill_brewer() +
  # scale_fill_grey(start = 0, end = 0.9) +
  theme_minimal(base_size = 10) +
  facet_grid(Term~agebin) +
  xlab("Square Placement") +
  ylab("Participant Count") +
  ylim(0, 35) +
  ggtitle("English Speakers (n = 113)") +
  theme(plot.title=element_text(family = "Times", color = "black", size = 10, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 10),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 10), 
        axis.title.x = element_text(family = "Times", color = "black", size = 10),
        axis.text.x = element_text(family = "Times", color = "black", size = 10)) +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                # panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black")) +
  theme(legend.position = "none") +
  # customize facet labels
  theme(
      strip.text.x = element_text(
        size = 10, color = "black", family = "Times"),
      strip.text.y = element_text(
        size = 10, color = "black", family = "Times")
      )

English_SquarePlacements

German_SquarePlacements <- ggplot(calhist.g, aes(x = factor(response1), fill = ColorBar)) +
  geom_bar(color = "black") +
  scale_fill_brewer() +
  theme_minimal(base_size = 10) +
  facet_grid(Term~agebin) +
  xlab("Square Placement") +
  ylab("") +
  ylim(0, 35) +
  ggtitle("German Speakers (n = 103)") +
  theme(plot.title=element_text(family = "Times", color = "black", size = 10, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 10),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 10), 
        axis.title.x = element_text(family = "Times", color = "black", size = 10),
        axis.text.x = element_text(family = "Times", color = "black", size = 10)) +
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black")) +
  theme(legend.position = "none") +
  #customize facet labels
  theme(
      strip.text.x = element_text(
        size = 10, color = "black", family = "Times"),
      strip.text.y = element_text(
        size = 10, color = "black", family = "Times")
      )

German_SquarePlacements

Figure2 <- ggarrange(English_SquarePlacements, German_SquarePlacements, 
          ncol = 2, nrow = 1)

ggsave(Figure2, file= "Figure2.jpeg", width = 8, height = 5, dpi = 300)
```

Graph Correct First Placement (but show proportion of kids who placed sticker in each box)
```{r}
#exclude 3- and 7-year-olds from cal.sum4
cal.sum4 <- cal.d2 %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>%
  group_by(language, agegroup, item, response1) %>%
  summarize(n = n()) %>%
  mutate(freq = n/sum(n))
```

Calendar Task: does language spoken, item, or age (in years) predict successful placement of time words in the past or the future? [interaction term included in the model]
```{r}
d.lm1 <- glmer(stat.correct.1 ~ language*item*scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) #FTC
summary(d.lm1) 
Anova(d.lm1, Type=3) #suggests there is a main effect of age, but no main effects of language, item or interactions
```

Calendar Task: does language spoken, item, or age (in years) predict successful placement of time words in the past or the future? [interaction term removed from the model]
```{r}
d.lm2 <- glmer(stat.correct.1 ~ language + item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) 
summary(d.lm2)
Anova(d.lm2, Type=3) #main effect of age
```

Does age or item predict successful placement of time words in the past vs. the future within each language group separately? [no interaction term]
```{r}
d.lm.2e <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.e) 
summary(d.lm.2e)
Anova(d.lm.2e, Type=3) #main effect of age

d.lm.2g <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.g) 
summary(d.lm.2g)
Anova(d.lm.2g, Type=3) #main effect of age
```

Knowledge of deictic status on Calendar task: does language group, age, and temporal location (proximal vs. distal) predict successful placement of time words in the past or the future? [interaction term included in the model]
```{r}
d.lm3 <-  glmer(stat.correct.1 ~ language*prox*scale(ageyears) + (1|subjid), family='binomial', data=cal.d) #FTC
summary(d.lm3)
Anova(d.lm3, Type=3) # suggests there are no main effects of language, proximity, or age and no interactions
```

Knowledge of deictic status on Calendar task: does language group, age, and temporal location (proximal vs. distal) predict successful placement of time words in the past or the future? [interaction term removed from the model]
```{r}
d.lm4 <-  glmer(stat.correct.1 ~ language + prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.d) 
summary(d.lm4)
Anova(d.lm4, Type=3) #main effect of age
```

Knowledge of deictic status on calendar task: Does age or temporal location (proximal vs. distal) predict successful placement of time words in the past vs. the future within each langauge group separately? [no interaction term]
```{r}
d.lm.4e <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.e) 
summary(d.lm.4e)
Anova(d.lm.4e, Type=3) #main effect of age

d.lm.4g <-  glmer(stat.correct.1 ~ prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.g) 
summary(d.lm.4g)
Anova(d.lm.4g, Type=3) #main effect of age
```

Knowledge of precise meanings on calendar Task: does language spoken, item,  or age (in years) predict successful placement of time words in the correct squares on the first try? [interaction term included in the model]

```{r}
cal.lm1 <- glmer(cor.first ~ language*item*scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) #FTC
summary(cal.lm1) 
Anova(cal.lm1, Type=3) # suggests there are effects of language, item, and ageyears with no interactions
```

Knowledge of precise meanings on calendar Task: does language spoken, item,  or age (in years) predict successful placement of time words in the correct squares on the first try? [interaction term removed from the model]
```{r}
cal.lm2 <- glmer(cor.first ~ language + item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.d) 
summary(cal.lm2)
Anova(cal.lm2, Type=3)
```

Does age or item predict successful placement of time words in the correct square on the first try within each language group separately? [no interaction term]
```{r}
cal.lm.2e <- glmer(cor.first ~ item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.e) 
summary(cal.lm.2e)
Anova(cal.lm.2e, Type=3)

cal.lm.2g <- glmer(cor.first ~ item + scale(ageyears) + (1|subjid), family = 'binomial', data=cal.g) 
summary(cal.lm.2g)
Anova(cal.lm.2g, Type=3)
```

Wilcox_test for item level comparisons (cor.first) within each language group separately
```{r}
#filter by language & remove 3 and 7-year-olds
cal.e2 <- cal.e %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, cor.first)
  #mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.g2 <- cal.g %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, cor.first)
  #mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

#Wilcox_test for item level comparisons
English.test <- cal.e2 %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = cor.first ~ item, p.adjust.method = "BH") %>%
  add_significance()
English.test

German.test <- cal.g2 %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = cor.first ~ item, p.adjust.method = "BH") %>%
  add_significance()
German.test

#filter by language & remove 3 and 7-year-olds
cal.d3 <- cal.d %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, cor.first, language, prox)
  #mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

language.test <- cal.d3 %>%
  group_by(agegroup, item) %>%
  pairwise_wilcox_test(formula = cor.first ~ language, p.adjust.method = "BH") %>%
  add_significance()
language.test

language.test2 <- cal.d3 %>%
  group_by(item) %>%
  pairwise_wilcox_test(formula = cor.first ~ language, p.adjust.method = "BH") %>%
  add_significance()
language.test2

language.proxTest <- cal.d3 %>%
  group_by(agegroup, prox) %>%
  pairwise_wilcox_test(formula = cor.first ~ language, p.adjust.method = "BH") %>%
  add_significance()
language.proxTest
# 0 = distal, 1 = proximal

# don't split it by age group
language.proxTest2 <- cal.d3 %>%
  group_by(prox) %>%
  pairwise_wilcox_test(formula = cor.first ~ language, p.adjust.method = "BH") %>%
  add_significance()
language.proxTest2
```


Does language group, age, and temporal location (proximal vs. distal) predict correct placement? [interaction term included in the model]
```{r}
cal.lm3 <-  glmer(cor.first ~ language*prox*scale(ageyears) + (1|subjid), family='binomial', data=cal.d) #FTC
summary(cal.lm3)
Anova(cal.lm3, Type=3) # suggests there are no main effects of language, proximity, or age and no interactions
```

Does language group, age, and temporal location (proximal vs. distal) predict correct placement? [interaction term removed from the model]
```{r}
cal.lm4 <-  glmer(cor.first ~ language + prox + scale(ageyears) + (1|subjid), family='binomial', data=cal.d) 
summary(cal.lm4)
Anova(cal.lm4, Type=3) #main effect of age
```

```{r}
#-language:prox:ageyears 
verbal <- d.all %>%
  filter(itemtype=="verbal" & agegroup %in% c('4','5') & item=="daysofweek") %>%
  group_by(language, item) %>%
  summarize(correct.m <- mean(correct))

### plot correct first placements (Did they give correct response first time)
correctPlacements <- ggplot(data=cal.sum, aes(x=agegroup, y=first.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
facet_wrap( ~ item, nrow=2) + 
theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
correctPlacements
ggsave(correctPlacements, file= "CorrectFirstPlacements.jpeg", width = 10, height = 10, dpi = 300)

#recode agegroup
cal.sum$agebin[cal.sum$agegroup == '4'] <- "Age 4"
cal.sum$agebin[cal.sum$agegroup == '5'] <- "Age 5"
cal.sum$agebin[cal.sum$agegroup == '6'] <- "Age 6"

#recode language spoken
cal.sum$languagegroup[cal.sum$language == 'english'] <- "English Speakers"
cal.sum$languagegroup[cal.sum$language == 'german'] <- "German Speakers"

#recode Item for Legend
cal.sum$Term[cal.sum$item == 'tomorrow'] <- "tomorrow"
cal.sum$Term[cal.sum$item == 'yesterday'] <- "yesterday"
cal.sum$Term[cal.sum$item == 'beforeyesterday'] <- "before-yesterday"
cal.sum$Term[cal.sum$item == 'aftertomorrow'] <- "after-tomorrow"

# now make the same graph as a bar graph
correctPlacementsBar <- ggplot(data=cal.sum, aes(x=agebin, y=first.m, fill=languagegroup)) +
  geom_bar(stat = 'identity', position = 'dodge')+
  ylab('Proportion Correct') +
  xlab('') +
  ylim(0,1) +
facet_wrap( ~ prox, nrow=2) + 
theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "right", legend.title = element_blank()) +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
correctPlacementsBar

# now make the same graph as a bar graph collapsed across age
correctPlacementsBar2 <- ggplot(data=cal.sum, aes(x=prox, y=first.m, fill=language)) +
  geom_bar(stat = 'identity', position = 'dodge')+
  ylab('Proportion Correct') +
  xlab('') +
  ylim(0,1) +
  facet_wrap( ~ agebin, nrow=1) +
theme_minimal(base_size = 18) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 18, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 18),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 18), 
        axis.title.x = element_text(family = "Times", color = "black", size = 18),
        axis.text.x = element_text(family = "Times", color = "black", size = 18)) +
          theme(legend.position = "right", legend.title = element_blank()) +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
correctPlacementsBar2

ggsave(correctPlacementsBar2, file= "CorrectFirstPlacementsBar2.jpeg", width = 15, height = 5, dpi = 300)
```

Plot correct first placements separately for each language group
```{r}
Englishcal_sum <- cal.sum %>%
  filter(language == "english")
Germancal_sum <- cal.sum %>%
  filter(language == "german")

EnglishPlacements <- ggplot(data = Englishcal_sum, aes(x=agebin, y = first.m, group = Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers (n = 116)') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "bottom") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
EnglishPlacements

GermanPlacements <- ggplot(data=Germancal_sum, aes(x=agebin, y = first.m, group = Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('') +
  xlab('German Speakers (n = 103)') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
GermanPlacements

CorrectFirstFigure <- ggarrange(EnglishPlacements, GermanPlacements,
                    ncol = 2, nrow = 1, common.legend = TRUE, legend = "top")
CorrectFirstFigure

ggsave(CorrectFirstFigure, file= "BoxPlacementByItem2.jpeg",  width = 10, height = 5, dpi = 300)
```

```{r}
#exclude 3- and 7-year-olds from cal.sum (and collapse across language)
cal.sum3 <- cal.d2 %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>% #for each word, how many kids got them right on the first try
   group_by(agegroup, item) %>%
  summarize(first.m = mean(cor.first, na.rm=T),     # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic1.m = mean(stat.correct.1), # who got correct status (first answer)
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            rank.m = mean(correct), # right box (final answer)
            countCor.first = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram

cal.sum3$agebin[cal.sum3$agegroup == '4'] <- "Age 4" #recode agegroup
cal.sum3$agebin[cal.sum3$agegroup == '5'] <- "Age 5"
cal.sum3$agebin[cal.sum3$agegroup == '6'] <- "Age 6"

cal.sum3$Term[cal.sum3$item == 'tomorrow'] <- "tomorrow" #recode item for Legend
cal.sum3$Term[cal.sum3$item == 'yesterday'] <- "yesterday"
cal.sum3$Term[cal.sum3$item == 'beforeyesterday'] <- "before-yesterday"
cal.sum3$Term[cal.sum3$item == 'aftertomorrow'] <- "after-tomorrow"
```

Plot correct status collapsed across language group (CogSci Figure 3)
```{r}
correctStatus <- ggplot(data=cal.sum3, 
                        aes(x=agebin, y=deictic1.m, group=Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = c(0.7, 0.2)) +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
          #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
correctStatus
ggsave(correctStatus, file= "correctStatus.jpeg", width = 5, height = 5, dpi = 300)
```

Plot correct status (again)
```{r}
correctStatus <- ggplot(data=cal.sum, 
                        aes(x=agegroup, y=deictic1.m, group=Term)) +
  geom_line(aes(linetype=Term)) +
  scale_linetype_manual(values=c("twodash", "dotted", "solid", "longdash"))+
  geom_point() +
  ylab('Proportion Correct') +
  ylim(0,1)
correctStatus
ggsave(correctStatus, file= "correctStatus.jpeg", width = 5, height = 5, dpi = 300)
```

Plot correct status by item (for each language separately)
```{r}
EnglishStatus <- ggplot(data=Englishcal_sum, aes(x=agebin, y=deictic1.m, group=item, color=item)) +
  geom_line(aes(color=item))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
EnglishStatus

GermanStatus <-ggplot(data=Germancal_sum, aes(x=agebin, y=deictic1.m, group=item, color=item)) +
  geom_line(aes(color=item))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab ('German Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
GermanStatus

CorrectStatusFigure <- ggarrange(EnglishStatus, GermanStatus,
                    ncol = 2, nrow = 1, common.legend = TRUE, legend = "top")
CorrectStatusFigure

ggsave(CorrectStatusFigure, file="correctStatusFigure.jpeg", width = 10, height = 5, dpi = 300)
```

```{r}
## check on bizarre results: English speaking older kids are doing worse with yesterday and tomorrow than the younger ones (not a problem anymore since we corrected the data files, yay!)
Englishcal_sum%>%
  group_by(item, agegroup) %>%
  summarize(mean(deictic.m))
cal.e %>%
  group_by(item, agegroup) %>%
  summarize(mean(stat.correct))
```

#check percentage of participants (in each language group separately) that were able to correctly recite the days of the week
```{r}
daysofweek <- d.all %>%
  select(-weekday, -ageyears, -order, -itemnum, -timelinefirst, -task, -linenum, -itemtype, -linelength, -distfrommid, -response2, -prompts, -item.stat, -stat.correct) %>%
  filter(item == "daysofweek")

German_daysofweek <- d.all %>%
  filter(language == "german", item == "daysofweek", exclude == "0") %>%
  select(subjid, agegroup, correct) %>%
  group_by(correct, agegroup) %>%
  summarise(n())

English_daysofweek <- d.all %>%
  filter(language == "english", item == "daysofweek", exclude == "0") %>%
  select(subjid, agegroup, correct) %>%
  group_by(correct, agegroup) %>%
  summarise(n())
```

##########################COGSCI PAPER ANALYSES END HERE##########################

#does age or item predict children's performance on verbal questions?
```{r}
Cal.v <- d.all %>%
  filter(task=="calendar" & itemtype == 'verbal') %>% # filter only verbal calendar items
  select(-order, -linenum, -linelength, -distfrommid, -correctr, -timelinefirst, -itemnum) %>%
  mutate(subjid = as.factor(subjid),
         cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox),
         agebin = case_when(agegroup == '4' ~ 'Age 4',
                            agegroup == '5' ~ 'Age 5',
                            agegroup == '6' ~ 'Age 6'))

#run model with age, item, and language group
age.verbal4 <- glmer(correct ~ language*item*scale(ageyears) + (1|subjid), family = binomial(link='logit'), data=Cal.v)
summary(age.verbal4)
Anova(age.verbal4, Type =3) # failed to converge

age.verbal5 <- glmer(correct ~ language + item + scale(ageyears) + (1|subjid), family = binomial(link='logit'), data=Cal.v)
summary(age.verbal5)
Anova(age.verbal5, Type =3) # failed to converge

age.verbal6 <- glm(correct ~ language + item + scale(ageyears), family = binomial(link='logit'), data=Cal.v)
summary(age.verbal6)
Anova(age.verbal6, Type =3)

# look at bargraph of proportion correct for each item to see what's going on (for each P how many trials did they get correct)

#calculate percentage of trials in which kids of each age group got verbal questions correct
verbal.sum <- Cal.v %>%
  filter(agegroup %in% c('4', '5', '6')) %>%
  group_by(language, agegroup, item, agebin) %>%
  summarize(correct.m.v = mean(correct, na.rm=T), # % who answered correctly
            sd.correct.v = sd(correct, na.rm=T), #calculate standard deviation
            n = n(),
            se.correct.v = sd.correct.v/sqrt(n)) #calculate standard error

ggplot(data = verbal.sum, aes (x = agegroup, y = correct.m.v, fill = language)) +
  geom_bar(stat = 'identity', position = 'dodge', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  labs(x = "Age", title = ('Proportions Correct by Age Group')) +
  facet_wrap(~item)

# make stand alone graph for days of the week
verbal.sum2 <- verbal.sum %>%
  filter(item == "daysofweek")

ggplot(data = verbal.sum2, aes(x=agebin, y = correct.m.v, fill = language)) +
  geom_bar(stat = 'identity', position = 'dodge') +
  labs(x = "", y = "Proportion Correct") +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "right", legend.title = element_blank()) +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
```

##########################BUCLD Abstract ANALYSES BEGIN HERE##########################

```{r}
# order measure from timeline task

# compare deictic status performance on timeline and calendar task (omit verbal Qs)
# is prop correct similar on the two tasks?

# calendar task gives you remoteness 
```










`````` ## go back and fix all the analyses below this line ------
#Cal.v$correct <- factor(Cal.v$correct) #tell r to use correct as a factor variable

#age.verbal <- glm(correct ~ scale(ageyears), family = binomial(link='logit'), data=Cal.v)
#summary(age.verbal)
#Anova(age.verbal, Type =3)

age.verbal2 <- glm(correct ~ item*scale(ageyears), family = binomial(link='logit'), data=Cal.v) #subject not included as a random factor
summary(age.verbal2)
Anova(age.verbal2, Type =3)

#### run above model again without the days of the week question
target_item <- c("aftertoday", "beforetoday", "today", "yesterday", "tomorrow")
Cal.v2 <- d.all %>%
  filter(task=="calendar" & itemtype == 'verbal' & item == target_item) %>% # filter verbal Qs but omit days of the week Q %>%
  select(-order, -linenum, -linelength, -distfrommid, -correctr, -timelinefirst, -itemnum) %>% # make sure correctR is # accurately coded
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

age.verbal3 <- glm(correct ~ item*scale(ageyears), family = binomial(link='logit'), data=Cal.v2)
summary(age.verbal3)
Anova(age.verbal3, Type =3)

##add language to the model
age.verbal4 <- glm(correct ~ language*item*scale(ageyears), family = binomial(link='logit'), data=Cal.v2)
summary(age.verbal4)
Anova(age.verbal4, Type =3)
```

Wilcox_test for item level comparisons (correct) within each language group separately
```{r}
#filter by language 
Cal.v2e <- Cal.v2 %>%
  filter(language == 'english') %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, correct)

Cal.v2g <- Cal.v2 %>%
  filter(language == 'german') %>%
  filter(agegroup %in% c('4','5','6')) %>%
  droplevels() %>%
  select(agegroup, item, correct)

#Wilcox_test for item level comparisons
English.testv <- Cal.v2e %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ item, p.adjust.method = "BH") %>%
  add_significance()
English.testv

# maybe not enough data to run this? many more NAs in German data compared to English data
German.testv <- Cal.v2g %>%
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ item, p.adjust.method = "BH") %>%
  add_significance()
German.testv
```
Calculate % of children who correctly answered verbal questions
```{r}
verbal_items <- c("aftertoday", "beforetoday", "yesterday", "tomorrow", "today")

#calculate percentage of trials in which kids of each age group got verbal questions correct
verbal.sum <- d.all %>%
  filter(itemtype == "verbal" & agegroup %in% c('4', '5', '6', '7') & item == verbal_items) %>% #filter only 5 verbal questions
  group_by(language, agegroup, item) %>%
  summarize(correct.m.v = mean(correct, na.rm=T), # % who answered correctly
            sd.correct.v = sd(correct, na.rm=T), #calculate standard deviation
            n = n(),
            se.correct.v = sd.correct.v/sqrt(n), #calculate standard error
            correctv.lower = correct.m.v - se.correct.v, # calculate lower 95% CI
            correctv.upper = correct.m.v + se.correct.v, # calculate upper 95% CI
            countCorrect.v = sum(correct, na.rm=T))  # sum proportion correct for making bar graph instead of histogram

verbal.sum2 <- d.all %>%
  filter(itemtype == "verbal" & agegroup %in% c('4', '5', '6', '7') & item == verbal_items) %>% #filter only 5 verbal questions
  group_by(language, agegroup) %>%
  summarize(correct.m.v = mean(correct, na.rm=T), # % who answered correctly
            sd.correct.v = sd(correct, na.rm=T), #calculate standard deviation
            n = n(),
            se.correct.v = sd.correct.v/sqrt(n), #calculate standard error
            correctv.lower = correct.m.v - se.correct.v, # calculate lower 95% CI
            correctv.upper = correct.m.v + se.correct.v, # calculate upper 95% CI
            countCorrect.v = sum(correct, na.rm=T))  # sum proportion correct for making bar graph instead of histogram

verbal.sum3 <- d.all %>%
  filter(itemtype == "verbal" & item == verbal_items) %>% #filter only 5 verbal questions
  group_by(agegroup) %>%
  summarize(correct.m.v = mean(correct, na.rm=T), # % who answered correctly
            sd.correct.v = sd(correct, na.rm=T), #calculate standard deviation
            n = n(),
            se.correct.v = sd.correct.v/sqrt(n), #calculate standard error
            correctv.lower = correct.m.v - se.correct.v, # calculate lower 95% CI
            correctv.upper = correct.m.v + se.correct.v, # calculate upper 95% CI
            countCorrect.v = sum(correct, na.rm=T))  # sum proportion correct for making bar graph instead of histogram

deictic.sum <- calv.d %>%
  filter(itemtype == "deictic" & agegroup %in% c('4', '5', '6', '7')) %>%
  group_by(language, agegroup, item) %>%
  summarize(correct.m.d = mean(cor.first, na.rm=T), # % who answered correctly
            sd.correct.d = sd(cor.first, na.rm=T),
            n = n(),
            se.correct.d = sd.correct.d/sqrt(n),
            deicticv.lower = correct.m.d - se.correct.d, # calculate lower 95% CI
            deicticv.upper = correct.m.d + se.correct.d, # calculate upper 95% CI
            countCorrect.d = sum(cor.first))  # sum proportion correct for making bar graph instead of histogram

sum.all <- rbind(verbal.sum, deictic.sum) # combine data into one data frame
sum.all.g <- sum.all %>%
  filter(language == "german")
sum.all.e <- sum.all %>%
  filter(language == "english")
```

##Did kids who answered verbal Qs correctly also answer Deictic Qs correctly?
##use verbal Q's to predict deictic Q's performance
```{r}
# create new data frame
target <- c("verbal", "deictic")
Cal.v3 <- d.all %>%
  filter(task=="calendar" & itemtype == target) %>% # filter only calendar %>%
  select(-order, -linenum, -linelength, -distfrommid, -correctr, -timelinefirst, -itemnum) %>% # make sure correctR is # accurately coded
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))

verbal.deictic <- glm(correct ~ itemtype, family = binomial(link='logit'), data=Cal.v3) #run logistic regression
summary(verbal.deictic)
Anova(verbal.deictic)

# add language to the model
verbalL.deictic2 <- glm(correct ~ itemtype + language, family = binomial(link='logit'), data=Cal.v3) #run logistic regression
summary(verbalL.deictic2)
Anova(verbalL.deictic2)

Calv.dg <- Cal.v3 %>% # filter out German participants only
  filter(language == "german")
German_VerbalQuestions <- ggplot(Calv.dg, aes(x = factor(correct))) +
  geom_bar(color = "black") +
  theme_minimal(base_size = 10) +
  facet_grid(itemtype~agegroup)
German_VerbalQuestions

German.test2 <- Calv.dg %>% # conduct Wilcox_test on German sample only
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
German.test2

Calv.de <- Cal.v3 %>% # filter out english participants only
  filter(language == "english")
English_VerbalQuestions <- ggplot(Calv.de, aes(x = factor(correct))) +
  geom_bar(color = "black") +
  theme_minimal(base_size = 10) +
  facet_grid(itemtype~agegroup)
English_VerbalQuestions

English.test2 <- Calv.de %>% # conduct Wilcox_test on english sample only
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
English.test2
  
```

##use verbal Q's to predict deictic Q's performance [split kids by if they recited days of week or not]
```{r}
Calv.d2 <- calv.d %>%
  filter(itemtype %in% c('verbal', 'deictic')) %>%
  select(subjid, agegroup, language, itemtype, item, correct)
Calv.d2T  <- reshape(Calv.d2, idvar = c("subjid", "agegroup"), timevar = "itemtype", direction = "wide")
# create new variable to code whether child correctly recited the days of the week
Calv.d2T <- Calv.d2T %>%
  mutate(daysofweek_cor = case_when(item.verbal == "daysofweek" & correct.verbal == '1' ~ '1',
                                  item.verbal == "daysofweek" & correct.verbal == '0' ~ '0'))

Calv.d2T1 <- Calv.d2T %>%
  filter(daysofweek_cor == '1') %>% #select only kids who correctly recited the days of the week
  select(-language.deictic)

Calv.d3 <- reshape(Calv.d2T1, #transpose data back to long format
                   direction = "long",
                   varying = c("correct.verbal", "correct.deictic"), 
                   v.names = c('correct'),
                   timevar = "itemtype", #1 = verbal, 2 = deictic
                   idvar = c("subjid", "agegroup"))

Calv.d3 <- Calv.d3 %>%
  mutate(item = case_when(itemtype == '1' ~ item.verbal, # recode new item variable
                          itemtype == '2' ~ item.deictic)) %>%
  mutate(itemtype = case_when(itemtype == '1' ~ 'verbal', # recode itemtype
                              itemtype == '2' ~ 'deictic')) %>%
  mutate(language = language.verbal) %>% # recode language
  select(-language.verbal, -item.verbal, -item.deictic) # remove duplicate columns

## For children who recited the days of the week, does performance on verbal Q's predict performance on deictic Q's?
verbal.deictic2 <- glm(correct ~ itemtype, family = binomial(link='logit'), data=Calv.d3) #run logistic regression
summary(verbal.deictic2)

Calv.d2T0 <- Calv.d2T %>%
  filter(daysofweek_cor == '0') %>% #select kids who did not correctly recite the days of the week
  select(-language.deictic)

Calv.d4 <- reshape(Calv.d2T0, #transpose data back to long format
                   direction = "long",
                   varying = c("correct.verbal", "correct.deictic"), 
                   v.names = c('correct'),
                   timevar = "itemtype", #1 = verbal, 2 = deictic
                   idvar = c("subjid", "agegroup"))

Calv.d4 <- Calv.d4 %>%
  mutate(item = case_when(itemtype == '1' ~ item.verbal, # recode new item variable
                          itemtype == '2' ~ item.deictic)) %>%
  mutate(itemtype = case_when(itemtype == '1' ~ 'verbal', # recode itemtype
                              itemtype == '2' ~ 'deictic')) %>%
  mutate(language = language.verbal) %>% # recode language
  select(-language.verbal, -item.verbal, -item.deictic) # remove duplicate columns

## For children who did not recite the days of the week correctly, does performance on verbal Q's predict performance on deictic Q's?
verbal.deictic3 <- glm(correct ~ itemtype, family = binomial(link='logit'), data=Calv.d4) # run logistic regression
summary(verbal.deictic3)

## run model on all kids (regardless of whether they recited the days of the week correctly or not)
# I think this model is redundant 
#Calv.d5 <- rbind(Calv.d3, Calv.d4)
#verbal.deictic4 <- glm(correct ~ itemtype, family = binomial(link='logit'), data=Calv.d5) #run logistic regression
#summary(verbal.deictic4)
#Anova(verbal.deictic4)
```

```{r}
remote1 <- glm(cor.remote ~ language + item + scale(ageyears), family = binomial(link='logit'), data=cal.d)
summary(remote1)
Anova(remote1)


English.remote <- Calv.de %>% # conduct Wilcox_test on English sample only
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
English.remote

German.remote <- Calv.dg %>% # conduct Wilcox_test on German sample only
  group_by(agegroup) %>%
  pairwise_wilcox_test(formula = correct ~ itemtype, p.adjust.method = "BH") %>%
  add_significance()
German.remote
```

# Plot Proportion Correct
```{r}
# first recode correct variable
cal.e$correct_cat[cal.e$correct == 0] <- 'Incorrect'
cal.e$correct_cat[cal.e$correct == 1] <- 'Correct'

# calculate proportions (English Data)
cal.eprop <- cal.e %>%
  count(agegroup, correct_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
as.data.frame(cal.eprop) # strip tbl_df() properties to print

# create ggplot
prop_e <- ggplot(data = cal.eprop, 
                 aes (x = agegroup, y = prop, fill = correct_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) + # or =waiver() or NULL for the default labels computed by the transformation object
  scale_fill_few('Medium', drop = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Placement',
       title = 'Proportions Correct by Age Group (English Data)')
prop_e

# just another way to calculate proportions
# cal_de_prop <- round(100*prop.table(table(cal.e$correct)), digits=0)
# cal_de_prop <- as.data.frame(cal_de_prop)

# first recode correct variable
cal.g$correct_cat[cal.g$correct == 0] <- 'Incorrect'
cal.g$correct_cat[cal.g$correct == 1] <- 'Correct'

# calculate proportions (German Data)
cal.gprop <- cal.g %>%
  count(agegroup, correct_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
cal.gprop <- as.data.frame(cal.gprop) # strip tbl_df() properties to print

# create ggplot
prop_g <- ggplot(data = cal.gprop, 
                 aes (x = agegroup, y = prop, fill = correct_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) +
  #scale_fill_few('medium', drops = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Placement',
       title = 'Proportions Correct by Age Group (German Data)')
prop_g
```
# graph prop correct for each verbal question separately
```{r}
# calculate proportions (English Data)
cal.eprop <- cal.e %>%
  count(agegroup, item, correct_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
as.data.frame(cal.eprop) # strip tbl_df() properties to print

# create ggplot
prop_e <- ggplot(data = cal.eprop, 
                 aes (x = agegroup, y = prop, fill = correct_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) + # or =waiver() or NULL for the default labels computed by the transformation object
  scale_fill_few('Medium', drop = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Placement',
       title = 'Proportions Correct by Age Group (English Data)') +
  facet_wrap(~item)
prop_e

# calculate proportions (German Data)
cal.gprop <- cal.g %>%
  count(agegroup, item, correct_cat) %>% # group_by() & summarize(n=n()) are implicit
  mutate(prop = prop.table(n)) # prop = n/sum(n) works too
cal.gprop <- as.data.frame(cal.gprop) # strip tbl_df() properties to print

# create ggplot
prop_g <- ggplot(data = cal.gprop, 
                 aes (x = agegroup, y = prop, fill = correct_cat)) +
  geom_bar(stat = 'identity', position = 'stack', alpha = 2/3) + # or use position = 'dodge' for grouped bars
  scale_y_continuous(labels = percent) +
  #scale_fill_few('medium', drops = FALSE) + # keeps levels if data is filtered
  labs(x = "Age", y = NULL, fill = 'Correct Placement',
       title = 'Proportions Correct by Age Group (German Data)') +
  facet_wrap(~item)
prop_g
```



# timeline analyses begin here 
```{r}
# Timelines ask reliability check: one-way mixed consistency, single measure ICC
# English sample only

TimeLine_Reliability <- d.e %>%
  select(distfrommid_c1, distfrommid_c2)
TimeLine_Reliability$distfrommid_c2<- as.numeric(TimeLine_Reliability$distfrommid_c2)
ICC(TimeLine_Reliability)
```

```{r}
# subset timeline data
d.all.timeline <- d.all %>%
  subset(task == "timeline")

# calculate maximum distance of each item placed on the timeline
d.all.timeline %>%
  group_by(itemtype, item) %>%
  summarize(average = mean(distfrommid_c1, na.rm=T), minimum = min(distfrommid_c1, na.rm = T), maximum = max(distfrommid_c1, na.rm=T)) # oops found a few TL coding errors that need to be checked/re-coded

# calculate maximum placement distance for each timeline
d.all.timeline %>%
  group_by(linenum) %>%
  summarize(average = mean(distfrommid_c1, na.rm=T), minimum = min(distfrommid_c1, na.rm = T), maximum = max(distfrommid_c1, na.rm=T)) # oops found a few TL coding errors that need to be checked/re-coded

# add maximum placements to dataframe
d.all <- d.all %>%
  mutate(dist_maxF = case_when(task == "timeline" & linenum == "1" ~ '7.4',
                                task == "timeline" & linenum == "2" ~ '7.3',
                                task == "timeline" & linenum == "3" ~ '7.5',
                                task == "timeline" & linenum == "4" ~ '7.2'),
         dist_maxP = case_when(task == "timeline" & linenum == "1" ~ '8.4', 
                               task == "timeline" & linenum == "2" ~ '7.2',
                               task == "timeline" & linenum == "3" ~ '7.3',
                               task == "timeline" & linenum == "4" ~ '7.7'))

# translate dist_max into numeric variable
d.all$dist_maxF <-as.numeric(d.all$dist_maxF)
d.all$dist_maxP <-as.numeric(d.all$dist_maxP)
                                  
# standardize distfrommid_c1 [raw distance/max distance on the given timeline] so that they range from -1 to 1
# check with Katharine that this is the correct way to standardize
d.all <- d.all %>%
  group_by(linenum) %>%
  mutate(distfrommid_std = case_when(task == "timeline" & distfrommid_c1 < 0 ~ (distfrommid_c1/dist_maxP),
                                     task == "timeline" & distfrommid_c1 > 0 ~ (distfrommid_c1/dist_maxF)))

# check and make sure scores were standardized correctly (this might correct itself once the coding has been fixed)
d.all %>%
  group_by(linenum) %>%
  summarize(minimum = min(distfrommid_std, na.rm = T), maximum = max(distfrommid_std, na.rm=T))
```

```{r}
# assess comprehension of the decitic status of time words on the timeline task only

# calculate percentage of trials kids of each age group responded with correct deictic status for each timeline
tl.sum <- d.all.timeline %>%
  group_by(agegroup, linenum, language) %>%
  summarize(n = n(),
            deictic.m = (mean(stat.correct)), # who got correct status
            deictic.sd = (sd(stat.correct)), # standard deviation
            deictic.se = deictic.sd/sqrt(n), # calculate standard error
            deictic.lower = deictic.m - deictic.se, # calculate lower 95% CI
            deictic.upper = deictic.m + deictic.se) # calculate upper 95% CI

English.tl.sum <- d.all.timeline %>%
  subset(language == "english") %>%
  group_by(agegroup, linenum) %>%
  summarize(n = n(),
            deictic.m = (mean(stat.correct)), # who got correct status
            deictic.sd = (sd(stat.correct)), # standard deviation
            deictic.se = deictic.sd/sqrt(n), # calculate standard error
            deictic.lower = deictic.m - deictic.se, # calculate lower 95% CI
            deictic.upper = deictic.m + deictic.se) # calculate upper 95% CI

German.tl.sum <- d.all.timeline %>%
  subset(language == "german") %>%
  group_by(agegroup, linenum) %>%
  summarize(n = n(),
            deictic.m = (mean(stat.correct)), # who got correct status
            deictic.sd = (sd(stat.correct)), # standard deviation
            deictic.se = deictic.sd/sqrt(n), # calculate standard error
            deictic.lower = deictic.m - deictic.se, # calculate lower 95% CI
            deictic.upper = deictic.m + deictic.se) # calculate upper 95% CI
```
# calculate average accuracy for all items' placement relative to "now" for each timeline and subject
```{r}
deictic_linenum <- d.all.timeline %>%
  group_by(subjid, linenum) %>%
  mutate(deictic.m = (mean(stat.correct))) # average correct status
```

# Plot correct status by timeline (for each language separately)
```{r}
EnglishStatus.tl <- ggplot(data=English.tl.sum, aes(x=agegroup, y=deictic.m, group=linenum, color=linenum)) +
  geom_line(aes(color=linenum))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
EnglishStatus.tl

GermanStatus.tl <-ggplot(data=German.tl.sum, aes(x=agegroup, y=deictic.m, group=linenum, color=linenum)) +
  geom_line(aes(color=linenum))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab ('German Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
GermanStatus.tl

CorrectStatus_timeline <- ggarrange(EnglishStatus.tl, GermanStatus.tl,
                    ncol = 2, nrow = 1, common.legend = TRUE, legend = "top")
CorrectStatus_timeline

# ggsave(CorrectStatus_timeline, file="correctStatus_timeline.jpeg", width = 10, height = 5, dpi = 300)
```
```{r}
# calculate percentage of trials kids of each age group responded with correct deictic status for each timeline type (deictic vs. event)

tl.sum2 <- d.all.timeline %>%
  group_by(agegroup, itemtype, language) %>%
  summarize(n = n(),
            deictic.m = (mean(stat.correct)), # who got correct status
            deictic.sd = (sd(stat.correct)), # standard deviation
            deictic.se = deictic.sd/sqrt(n), # calculate standard error
            deictic.lower = deictic.m - deictic.se, # calculate lower 95% CI
            deictic.upper = deictic.m + deictic.se) # calculate upper 95% CI

English.tl.sum2 <- d.all.timeline %>%
  subset(language == "english") %>%
  group_by(agegroup, itemtype) %>%
  summarize(n = n(),
            deictic.m = (mean(stat.correct)), # who got correct status
            deictic.sd = (sd(stat.correct)), # standard deviation
            deictic.se = deictic.sd/sqrt(n), # calculate standard error
            deictic.lower = deictic.m - deictic.se, # calculate lower 95% CI
            deictic.upper = deictic.m + deictic.se) # calculate upper 95% CI

German.tl.sum2 <- d.all.timeline %>%
  subset(language == "german") %>%
  group_by(agegroup, itemtype) %>%
  summarize(n = n(),
            deictic.m = (mean(stat.correct)), # who got correct status
            deictic.sd = (sd(stat.correct)), # standard deviation
            deictic.se = deictic.sd/sqrt(n), # calculate standard error
            deictic.lower = deictic.m - deictic.se, # calculate lower 95% CI
            deictic.upper = deictic.m + deictic.se) # calculate upper 95% CI
```
# Calculate mean deictic status accuracy for each subject and each type of timeline (Deictic vs. Event). 
```{r}
deictic_itemtype <- d.all.timeline %>%
  group_by(subjid, itemtype) %>%
  mutate(deictic.m = (mean(stat.correct))) # average correct status
```


Plot correct status by item type (for each language separately)
```{r}
EnglishStatus.tl2 <- ggplot(data=English.tl.sum2, aes(x=agegroup, y=deictic.m, group=itemtype, color=itemtype)) +
  geom_line(aes(color=itemtype))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab('English Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
EnglishStatus.tl2

GermanStatus.tl2 <-ggplot(data=German.tl.sum2, aes(x=agegroup, y=deictic.m, group=itemtype, color=itemtype)) +
  geom_line(aes(color=itemtype))+
  geom_point() +
  ylab('Proportion Correct') +
  xlab ('German Speakers') +
  ylim(0,1) +
  theme_minimal(base_size = 14) +
  theme(plot.title=element_text(family = "Times", color = "black", size = 14, hjust = 0.5), 
        axis.title.y = element_text(family = "Times", color = "black", size = 14),
        axis.line.y = element_line(color = "black"),
        axis.text.y = element_text(family = "Times", color = "black", size = 14), 
        axis.title.x = element_text(family = "Times", color = "black", size = 14),
        axis.text.x = element_text(family = "Times", color = "black", size = 14)) +
          theme(legend.position = "top") +
          theme(panel.border = element_rect(colour = "black", fill = NA, size = 1),
                #panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
                axis.line = element_line(colour = "black"))
GermanStatus.tl2

CorrectStatus_timeline2 <- ggarrange(EnglishStatus.tl2, GermanStatus.tl2,
                    ncol = 2, nrow = 1, common.legend = TRUE, legend = "top")
CorrectStatus_timeline2

# ggsave(CorrectStatus_timeline, file="correctStatus_timeline.jpeg", width = 10, height = 5, dpi = 300)
```
```{r}
# Analyze deictic status accuracy with a three-way mixed ANOVA, with item Type (Deictic vs. Event) as a within-subjects factor and Age (3 through 7 years) and language  (German vs. English) as between-subject factors. 

deictic_itemtype %>%
  group_by(itemtype, agegroup, language) %>%
  get_summary_stats(deictic.m, type="mean_sd")

# visualize the data
deictic_bxp <- ggboxplot(
  deictic_itemtype, x = "agegroup", y = "deictic.m",
  color = "itemtype", palette = "jco",
  facet.by = "language"
)
deictic_bxp

# check for outliers
deictic_itemtype %>%
  group_by(agegroup, itemtype, language) %>%
  identify_outliers(deictic.m) # looks like there are some extreme outliers - check with Katharine about this

# check normality assumption (ask Katharine if we need to worry about this)

deictic_itemtype %>%
  group_by(agegroup, itemtype, language) %>%
  shapiro_test(deictic.m)

# re-number subjid variable
#deictic_itemtype <- deictic_itemtype %>%
  #mutate(num=group_indices_(deictic_itemtype, .dots =c('subjid')))

# convert itemtype to factor length variable
deictic_itemtype <- deictic_itemtype %>%
  convert_as_factor(itemtype)

#recode itemtype
deictic_itemtype$itemtype2[deictic_itemtype$itemtype == 'event'] <- 1
deictic_itemtype$itemtype2[deictic_itemtype$itemtype == 'deictic'] <- 2

# convert itemtype2 to factor length variable
deictic_itemtype <- deictic_itemtype %>%
  convert_as_factor(itemtype2)

deictic.aov <- anova_test(
  data = deictic_itemtype, dv = deictic.m, wid = subjid, 
  within = itemtype2, between = c(agegroup, language)
)
get_anova_table(deictic.aov)
```


```{r}
# need to wait on adult comparison data to test knowledge of remoteness
# calculate percentage of trials in which kids of each age group responded with correct remoteness on calendar questions
# tl.sum1 <- d.all.timeline %>%
  # group_by(agegroup, linenum, language) %>%
  # summarize(n = n(),
            # remoteness.m = (mean(cor.remote))*100, # who got correct status (first answer)
            # remoteness.sd = (sd(cor.remote))*100, # standard deviation
            # remoteness.se = remoteness.sd/sqrt(n), # calculate standard error
            # remoteness.lower = remoteness.m - remoteness.se, # calculate lower 95% CI
            # remoteness.upper = remoteness.m + remoteness.se) # calculate upper 95% CI
```



#################################### completed analyses end here 

#What are errors based on? distance from today?
#first.m = mean(cor.first, na.rm=T),     # average # of participants who put item in right box on first try
            #sd.correct = sd(cor.first, na.rm=T),
            #se.correct = sd.correct/sqrt(n),
            #deictic.m = mean(stat.correct), # average #participants who got correct status
            
###Did children place paired distal, proximal, past, and future items in the correct location? (e.g., correct placement for both tomorrow/after tomorrow)
```{r}
#create new data frame
cal.allT <- cal.d %>%
  select (subjid, agegroup, language, item, correct)
#transpose item (i.e., transform from long to wide format)
cal.allT <- reshape(cal.allT, idvar = c("subjid", "agegroup", "language"), timevar = "item", direction = "wide")

#Code for tomorrow & yesterday both correct (proxCorr = 1)
cal.allT <- cal.allT %>%
  mutate(proxCorr = case_when(correct.tomorrow == "1" & correct.yesterday == "1" ~ 1, TRUE ~ 0)) %>%
#Code for after tomorrow & before yesterday both correct (distCorr = 1)
  mutate(distCorr = case_when(correct.aftertomorrow == "1" & correct.beforeyesterday == "1" ~ 1, TRUE ~ 0)) %>%
#Code for tomorrow & after tomorrow correct (tomorrow2Corr = 1)
  mutate(tomorrow2Corr = case_when(correct.tomorrow == "1" & correct.aftertomorrow == "1" ~ 1, TRUE ~ 0)) %>%
#Code for yesterday & before yesterday correct (yesterday2Corr = 1)
  mutate(yesterday2Corr = case_when(correct.yesterday == "1" & correct.beforeyesterday == "1" ~ 1, TRUE ~ 0))

#create new data frame (again) and transpose from wide format back to long format
cal.allTrecoded <- cal.allT %>%
  select(subjid, agegroup, language, proxCorr, distCorr, tomorrow2Corr, yesterday2Corr)
cal.allTrecoded <- reshape(cal.allTrecoded,
                           idvar = "subjid", 
                           varying = list(c(4, 5, 6, 7)), 
                           direction = "long", 
                           v.names = c('BothCorr'), 
                           timevar = "Pair")
#rename values in 'Pair' variable column
cal.allTrecoded <- cal.allTrecoded %>%
  mutate(Pair = as.factor(Pair), 
         item = recode_factor(Pair, '1' = 'proxCorr', 
                              '2' = 'distCorr', 
                              '3' = 'tomorrow2Corr', 
                              '4' = 'yesterday2Corr'))

#counts just to make sure data was transposed correctly (without error)
#counts for wide data frame (English Ps only)
#proxCorr_countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, proxCorr) %>%
  #summarise(Freq=n())
#distCorr_countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup,distCorr) %>%
  #summarise(Freq=n())
#tomorrow2Corr.countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, tomorrow2Corr) %>%
  #summarise(Freq=n())
#yesterday2Corr.countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, yesterday2Corr) %>%
  #summarise(Freq=n())

#counts for long data frame
#proxCorr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "proxCorr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#distCorr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "distCorr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#tomorrow2corr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "tomorrow2Corr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#yesterday2Corr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "yesterday2Corr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())

###plot number of participants who answered pairs of questions correctly: distal Qs, proximal Qs, tomorrow/after tomorrow Qs, yesterday/before yesterday Qs.
ggplot(cal.allTrecoded, aes(x=BothCorr)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 0.5) +
  xlab("1 = both correct") +
  facet_grid(item ~ agegroup)
ggplot(data=cal.allTrecoded, aes(x = BothCorr)) +
  geom_bar() +
  geom_text(stat='count', aes(label = ..count..), vjust = -1) +
  facet_wrap(language ~ item, nrow = 4)

###plot proportion of participants who answered pairs of questions correctly: distal Qs, proximal Qs, tomorrow Qs, yesterday Qs.
##1 = both correct, 0 = one or more incorrect responses for paired stimuli (e.g., tomorrow & day after tomorrow)
cal.allTrecoded[,'BothCorrF'] <- as.factor(cal.allTrecoded[,'BothCorr'])
Prop_Graph <- ggplot(cal.allTrecoded, aes(x=item, fill = BothCorrF)) +
  geom_bar(position = "fill") +
  coord_flip() +
  ylab('proportion of participants') +
  facet_wrap(language ~ agegroup)


cal.sumPairs <- cal.allTrecoded %>%
#for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(bothcorrect.m = mean(BothCorr, na.rm=T),     # % who put item in right box on first try
            sd.bothcorrect = sd(BothCorr, na.rm=T),
            n = n(),
            se.bothcorrect = sd.bothcorrect/sqrt(n))

### plot if paired items both correct (correct response first time)
CorrectPairs <- ggplot(data=cal.sumPairs, aes(x=agegroup, y=bothcorrect.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
facet_wrap( ~ item, nrow=2) 
CorrectPairs

ggsave(CorrectPairs, file= "PairedItems_PropCorrect.jpeg", width = 10, height = 10, dpi = 300)

#plot if paired items both placed correctly on the first try (for each language separately)
Englishcal.sumPairs <- cal.sumPairs %>%
  filter(language == "english")

Germancal.sumPairs <- cal.sumPairs %>%
  filter(language == "german")

CorrectPairsEnglish <- ggplot(data=Englishcal.sumPairs, aes(x = agegroup, y =bothcorrect.m, group=item, color=item)) +
  geom_line(aes(color = item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0, 1)
CorrectPairsEnglish

CorrectPairsGerman <- ggplot(data=Germancal.sumPairs, aes(x = agegroup, y =bothcorrect.m, group=item, color=item)) +
  geom_line(aes(color = item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0, 1)

CorrectPairsFigure <- ggarrange(CorrectPairsEnglish, CorrectPairsGerman,
                    labels = c("English", "German"),
                    ncol = 2, nrow = 1)
CorrectPairsFigure
```

```{r}
#compare performance between time words (within each language separately)
ggboxplot(Englishcal_sum, x = "item", y = "first.m",
          color = "item",
          ylab = "% who put item in right box on first try", xlab = "items", 
          ylim=c(0.2, 1.0)) +
  ggtitle("English Speakers")

ggboxplot(Germancal_sum, x = "item", y = "first.m",
          color = "item",
          ylab = "% who put item in right box on first try", xlab = "items", 
          ylim=c(0.2, 1.0)) +
  ggtitle("German Speakers")
```

```{r}
#compare performance between time words by age group (within each language separately)
English_boxplot <- ggboxplot(Englishcal_sum, x = "item", y = "first.m",
          color = "item", 
          ylab = "% who put item in right box on first try", xlab = "items",
          ylim=c(0, 1.0),
          facet.by = "agegroup",
          nrow = 3,
          ncol = 1) +
  ggtitle("English Speakers")
English_boxplot
ggsave(English_boxplot, file= "EnglishBoxPlot.jpeg", width = 12, height = 10, dpi = 300)

German_boxplot <- ggboxplot(Germancal_sum, x = "item", y = "first.m",
          color = "item", 
          ylab = "% who put item in right box on first try", xlab = "items",
          ylim=c(0, 1.0),
          facet.by = "agegroup",
          nrow = 3,
          ncol = 1) +
  ggtitle("German Speakers")
German_boxplot
ggsave(German_boxplot, file= "GermanBoxPlot.jpeg", width = 12, height = 10, dpi = 300)
```


#Mixed-effects logistic regression examining the effects of age, and verbal Qs on childrens successful placement of time words in the correct squares on the first try
```{r}
#create new data frame (english only)
#vd.e <- d.all %>%
  #filter(language == 'english', task=="calendar" & itemtype %in% c("deictic", "verbal") & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  #select(-linelength,-distfrommid) %>%
  #mutate(#response = ifelse(is.na(response2) == T, response1, response2), #this is redundant
         #response = as.numeric(response), #this is redundant 
         #cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         #prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), #yesterday and tomorrow coded as proximal terms
         #prox = as.factor(prox))

#English participants only
#vd.lm.e = glmer(correct ~ itemtype*ageyears + (1|subjid), family='binomial', data=vd.e)
#summary(vd.lm.e)

#create new data frame (german only)
#vd.g <- d.all %>%
   #filter(language == 'german', task=="calendar" & itemtype %in% c("deictic", "verbal") & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  #select(-linelength,-distfrommid) %>%
  #mutate(#response = ifelse(is.na(response2) == T, response1, response2), #this is redundant
         #response = as.numeric(response), #this is redundant 
         #cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         #prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), #yesterday and tomorrow coded as proximal terms
         #prox = as.factor(prox))
#German participants only
#vd.lm.g = glmer(cor.first ~ itemtype + ageyears + (1|subjid), family='binomial', data=vd.g)
#summary(vd.lm.g)
```

##Sum # of words correct (4 correct? 3 correct? etc.)
